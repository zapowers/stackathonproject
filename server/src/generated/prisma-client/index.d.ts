// Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  creature: (where?: CreatureWhereInput) => Promise<boolean>;
  encounter: (where?: EncounterWhereInput) => Promise<boolean>;
  encounterCreature: (where?: EncounterCreatureWhereInput) => Promise<boolean>;
  party: (where?: PartyWhereInput) => Promise<boolean>;
  savedParty: (where?: SavedPartyWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  creature: (where: CreatureWhereUniqueInput) => CreatureNullablePromise;
  creatures: (args?: {
    where?: CreatureWhereInput;
    orderBy?: CreatureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Creature>;
  creaturesConnection: (args?: {
    where?: CreatureWhereInput;
    orderBy?: CreatureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CreatureConnectionPromise;
  encounter: (where: EncounterWhereUniqueInput) => EncounterNullablePromise;
  encounters: (args?: {
    where?: EncounterWhereInput;
    orderBy?: EncounterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Encounter>;
  encountersConnection: (args?: {
    where?: EncounterWhereInput;
    orderBy?: EncounterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EncounterConnectionPromise;
  encounterCreatures: (args?: {
    where?: EncounterCreatureWhereInput;
    orderBy?: EncounterCreatureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<EncounterCreature>;
  encounterCreaturesConnection: (args?: {
    where?: EncounterCreatureWhereInput;
    orderBy?: EncounterCreatureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EncounterCreatureConnectionPromise;
  party: (where: PartyWhereUniqueInput) => PartyNullablePromise;
  parties: (args?: {
    where?: PartyWhereInput;
    orderBy?: PartyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Party>;
  partiesConnection: (args?: {
    where?: PartyWhereInput;
    orderBy?: PartyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PartyConnectionPromise;
  savedParty: (where: SavedPartyWhereUniqueInput) => SavedPartyNullablePromise;
  savedParties: (args?: {
    where?: SavedPartyWhereInput;
    orderBy?: SavedPartyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SavedParty>;
  savedPartiesConnection: (args?: {
    where?: SavedPartyWhereInput;
    orderBy?: SavedPartyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SavedPartyConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCreature: (data: CreatureCreateInput) => CreaturePromise;
  updateCreature: (args: {
    data: CreatureUpdateInput;
    where: CreatureWhereUniqueInput;
  }) => CreaturePromise;
  updateManyCreatures: (args: {
    data: CreatureUpdateManyMutationInput;
    where?: CreatureWhereInput;
  }) => BatchPayloadPromise;
  upsertCreature: (args: {
    where: CreatureWhereUniqueInput;
    create: CreatureCreateInput;
    update: CreatureUpdateInput;
  }) => CreaturePromise;
  deleteCreature: (where: CreatureWhereUniqueInput) => CreaturePromise;
  deleteManyCreatures: (where?: CreatureWhereInput) => BatchPayloadPromise;
  createEncounter: (data: EncounterCreateInput) => EncounterPromise;
  updateEncounter: (args: {
    data: EncounterUpdateInput;
    where: EncounterWhereUniqueInput;
  }) => EncounterPromise;
  updateManyEncounters: (args: {
    data: EncounterUpdateManyMutationInput;
    where?: EncounterWhereInput;
  }) => BatchPayloadPromise;
  upsertEncounter: (args: {
    where: EncounterWhereUniqueInput;
    create: EncounterCreateInput;
    update: EncounterUpdateInput;
  }) => EncounterPromise;
  deleteEncounter: (where: EncounterWhereUniqueInput) => EncounterPromise;
  deleteManyEncounters: (where?: EncounterWhereInput) => BatchPayloadPromise;
  createEncounterCreature: () => EncounterCreaturePromise;
  deleteManyEncounterCreatures: (
    where?: EncounterCreatureWhereInput
  ) => BatchPayloadPromise;
  createParty: (data: PartyCreateInput) => PartyPromise;
  updateParty: (args: {
    data: PartyUpdateInput;
    where: PartyWhereUniqueInput;
  }) => PartyPromise;
  updateManyParties: (args: {
    data: PartyUpdateManyMutationInput;
    where?: PartyWhereInput;
  }) => BatchPayloadPromise;
  upsertParty: (args: {
    where: PartyWhereUniqueInput;
    create: PartyCreateInput;
    update: PartyUpdateInput;
  }) => PartyPromise;
  deleteParty: (where: PartyWhereUniqueInput) => PartyPromise;
  deleteManyParties: (where?: PartyWhereInput) => BatchPayloadPromise;
  createSavedParty: (data: SavedPartyCreateInput) => SavedPartyPromise;
  updateSavedParty: (args: {
    data: SavedPartyUpdateInput;
    where: SavedPartyWhereUniqueInput;
  }) => SavedPartyPromise;
  updateManySavedParties: (args: {
    data: SavedPartyUpdateManyMutationInput;
    where?: SavedPartyWhereInput;
  }) => BatchPayloadPromise;
  upsertSavedParty: (args: {
    where: SavedPartyWhereUniqueInput;
    create: SavedPartyCreateInput;
    update: SavedPartyUpdateInput;
  }) => SavedPartyPromise;
  deleteSavedParty: (where: SavedPartyWhereUniqueInput) => SavedPartyPromise;
  deleteManySavedParties: (where?: SavedPartyWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  creature: (
    where?: CreatureSubscriptionWhereInput
  ) => CreatureSubscriptionPayloadSubscription;
  encounter: (
    where?: EncounterSubscriptionWhereInput
  ) => EncounterSubscriptionPayloadSubscription;
  encounterCreature: (
    where?: EncounterCreatureSubscriptionWhereInput
  ) => EncounterCreatureSubscriptionPayloadSubscription;
  party: (
    where?: PartySubscriptionWhereInput
  ) => PartySubscriptionPayloadSubscription;
  savedParty: (
    where?: SavedPartySubscriptionWhereInput
  ) => SavedPartySubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type CreatureOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "armorClass_ASC"
  | "armorClass_DESC"
  | "attackDiceType_ASC"
  | "attackDiceType_DESC"
  | "attackHitDieNumber_ASC"
  | "attackHitDieNumber_DESC"
  | "attackNameAndType_ASC"
  | "attackNameAndType_DESC"
  | "attackPointsAdd_ASC"
  | "attackPointsAdd_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "eighthLevelSpells_ASC"
  | "eighthLevelSpells_DESC"
  | "fifthLevelSpells_ASC"
  | "fifthLevelSpells_DESC"
  | "firstLevelSpells_ASC"
  | "firstLevelSpells_DESC"
  | "fourthLevelSpells_ASC"
  | "fourthLevelSpells_DESC"
  | "hitDiceNumber_ASC"
  | "hitDiceNumber_DESC"
  | "hitDiceType_ASC"
  | "hitDiceType_DESC"
  | "hitPointsAdd_ASC"
  | "hitPointsAdd_DESC"
  | "imageUrl_ASC"
  | "imageUrl_DESC"
  | "initiativeBonus_ASC"
  | "initiativeBonus_DESC"
  | "movementSpeed_ASC"
  | "movementSpeed_DESC"
  | "name_ASC"
  | "name_DESC"
  | "ninthLevelSpells_ASC"
  | "ninthLevelSpells_DESC"
  | "secondAttackDiceType_ASC"
  | "secondAttackDiceType_DESC"
  | "secondAttackHitDieNumber_ASC"
  | "secondAttackHitDieNumber_DESC"
  | "secondAttackNameAndType_ASC"
  | "secondAttackNameAndType_DESC"
  | "secondAttackPointsAdd_ASC"
  | "secondAttackPointsAdd_DESC"
  | "secondLevelSpells_ASC"
  | "secondLevelSpells_DESC"
  | "secondToHitBonus_ASC"
  | "secondToHitBonus_DESC"
  | "seventhLevelSpells_ASC"
  | "seventhLevelSpells_DESC"
  | "sixthLevelSpells_ASC"
  | "sixthLevelSpells_DESC"
  | "spellAttack_ASC"
  | "spellAttack_DESC"
  | "spellSave_ASC"
  | "spellSave_DESC"
  | "thirdLevelSpells_ASC"
  | "thirdLevelSpells_DESC"
  | "toHitBonus_ASC"
  | "toHitBonus_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EncounterCreatureOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EncounterOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PartyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "armorClass_ASC"
  | "armorClass_DESC"
  | "attackDiceType_ASC"
  | "attackDiceType_DESC"
  | "attackHitDieNumber_ASC"
  | "attackHitDieNumber_DESC"
  | "attackNameAndType_ASC"
  | "attackNameAndType_DESC"
  | "attackPointsAdd_ASC"
  | "attackPointsAdd_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "eighthLevelSpells_ASC"
  | "eighthLevelSpells_DESC"
  | "fifthLevelSpells_ASC"
  | "fifthLevelSpells_DESC"
  | "firstLevelSpells_ASC"
  | "firstLevelSpells_DESC"
  | "fourthLevelSpells_ASC"
  | "fourthLevelSpells_DESC"
  | "hitDiceNumber_ASC"
  | "hitDiceNumber_DESC"
  | "hitDiceType_ASC"
  | "hitDiceType_DESC"
  | "hitPoints_ASC"
  | "hitPoints_DESC"
  | "hitPointsAdd_ASC"
  | "hitPointsAdd_DESC"
  | "imageUrl_ASC"
  | "imageUrl_DESC"
  | "initiativeBonus_ASC"
  | "initiativeBonus_DESC"
  | "movementSpeed_ASC"
  | "movementSpeed_DESC"
  | "name_ASC"
  | "name_DESC"
  | "ninthLevelSpells_ASC"
  | "ninthLevelSpells_DESC"
  | "secondAttackDiceType_ASC"
  | "secondAttackDiceType_DESC"
  | "secondAttackHitDieNumber_ASC"
  | "secondAttackHitDieNumber_DESC"
  | "secondAttackNameAndType_ASC"
  | "secondAttackNameAndType_DESC"
  | "secondAttackPointsAdd_ASC"
  | "secondAttackPointsAdd_DESC"
  | "secondLevelSpells_ASC"
  | "secondLevelSpells_DESC"
  | "secondToHitBonus_ASC"
  | "secondToHitBonus_DESC"
  | "seventhLevelSpells_ASC"
  | "seventhLevelSpells_DESC"
  | "sixthLevelSpells_ASC"
  | "sixthLevelSpells_DESC"
  | "spellAttack_ASC"
  | "spellAttack_DESC"
  | "spellSave_ASC"
  | "spellSave_DESC"
  | "thirdLevelSpells_ASC"
  | "thirdLevelSpells_DESC"
  | "toHitBonus_ASC"
  | "toHitBonus_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SavedPartyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface EncounterCreatureUpdateManyInput {
  deleteMany?: Maybe<
    EncounterCreatureScalarWhereInput[] | EncounterCreatureScalarWhereInput
  >;
}

export type CreatureWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface SavedPartyWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  parties_every?: Maybe<PartyWhereInput>;
  parties_some?: Maybe<PartyWhereInput>;
  parties_none?: Maybe<PartyWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SavedPartyWhereInput[] | SavedPartyWhereInput>;
  OR?: Maybe<SavedPartyWhereInput[] | SavedPartyWhereInput>;
  NOT?: Maybe<SavedPartyWhereInput[] | SavedPartyWhereInput>;
}

export interface EncounterUpdateInput {
  encounterCreature?: Maybe<EncounterCreatureUpdateManyInput>;
  name?: Maybe<String>;
}

export interface PartyCreateWithoutSavedPartyIdInput {
  armorClass?: Maybe<Int>;
  attackDiceType?: Maybe<Int>;
  attackHitDieNumber?: Maybe<Int>;
  attackNameAndType?: Maybe<String>;
  attackPointsAdd?: Maybe<Int>;
  eighthLevelSpells?: Maybe<Int>;
  fifthLevelSpells?: Maybe<Int>;
  firstLevelSpells?: Maybe<Int>;
  fourthLevelSpells?: Maybe<Int>;
  hitDiceNumber?: Maybe<Int>;
  hitDiceType?: Maybe<Int>;
  hitPoints?: Maybe<Int>;
  hitPointsAdd?: Maybe<Int>;
  imageUrl?: Maybe<String>;
  initiativeBonus?: Maybe<Int>;
  movementSpeed?: Maybe<Int>;
  name: String;
  ninthLevelSpells?: Maybe<Int>;
  secondAttackDiceType?: Maybe<Int>;
  secondAttackHitDieNumber?: Maybe<Int>;
  secondAttackNameAndType?: Maybe<String>;
  secondAttackPointsAdd?: Maybe<Int>;
  secondLevelSpells?: Maybe<Int>;
  secondToHitBonus?: Maybe<Int>;
  seventhLevelSpells?: Maybe<Int>;
  sixthLevelSpells?: Maybe<Int>;
  spellAttack?: Maybe<Int>;
  spellSave?: Maybe<Int>;
  thirdLevelSpells?: Maybe<Int>;
  toHitBonus?: Maybe<Int>;
}

export interface CreatureWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  armorClass?: Maybe<Int>;
  armorClass_not?: Maybe<Int>;
  armorClass_in?: Maybe<Int[] | Int>;
  armorClass_not_in?: Maybe<Int[] | Int>;
  armorClass_lt?: Maybe<Int>;
  armorClass_lte?: Maybe<Int>;
  armorClass_gt?: Maybe<Int>;
  armorClass_gte?: Maybe<Int>;
  attackDiceType?: Maybe<Int>;
  attackDiceType_not?: Maybe<Int>;
  attackDiceType_in?: Maybe<Int[] | Int>;
  attackDiceType_not_in?: Maybe<Int[] | Int>;
  attackDiceType_lt?: Maybe<Int>;
  attackDiceType_lte?: Maybe<Int>;
  attackDiceType_gt?: Maybe<Int>;
  attackDiceType_gte?: Maybe<Int>;
  attackHitDieNumber?: Maybe<Int>;
  attackHitDieNumber_not?: Maybe<Int>;
  attackHitDieNumber_in?: Maybe<Int[] | Int>;
  attackHitDieNumber_not_in?: Maybe<Int[] | Int>;
  attackHitDieNumber_lt?: Maybe<Int>;
  attackHitDieNumber_lte?: Maybe<Int>;
  attackHitDieNumber_gt?: Maybe<Int>;
  attackHitDieNumber_gte?: Maybe<Int>;
  attackNameAndType?: Maybe<String>;
  attackNameAndType_not?: Maybe<String>;
  attackNameAndType_in?: Maybe<String[] | String>;
  attackNameAndType_not_in?: Maybe<String[] | String>;
  attackNameAndType_lt?: Maybe<String>;
  attackNameAndType_lte?: Maybe<String>;
  attackNameAndType_gt?: Maybe<String>;
  attackNameAndType_gte?: Maybe<String>;
  attackNameAndType_contains?: Maybe<String>;
  attackNameAndType_not_contains?: Maybe<String>;
  attackNameAndType_starts_with?: Maybe<String>;
  attackNameAndType_not_starts_with?: Maybe<String>;
  attackNameAndType_ends_with?: Maybe<String>;
  attackNameAndType_not_ends_with?: Maybe<String>;
  attackPointsAdd?: Maybe<Int>;
  attackPointsAdd_not?: Maybe<Int>;
  attackPointsAdd_in?: Maybe<Int[] | Int>;
  attackPointsAdd_not_in?: Maybe<Int[] | Int>;
  attackPointsAdd_lt?: Maybe<Int>;
  attackPointsAdd_lte?: Maybe<Int>;
  attackPointsAdd_gt?: Maybe<Int>;
  attackPointsAdd_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  eighthLevelSpells?: Maybe<Int>;
  eighthLevelSpells_not?: Maybe<Int>;
  eighthLevelSpells_in?: Maybe<Int[] | Int>;
  eighthLevelSpells_not_in?: Maybe<Int[] | Int>;
  eighthLevelSpells_lt?: Maybe<Int>;
  eighthLevelSpells_lte?: Maybe<Int>;
  eighthLevelSpells_gt?: Maybe<Int>;
  eighthLevelSpells_gte?: Maybe<Int>;
  encounterCreature_every?: Maybe<EncounterCreatureWhereInput>;
  encounterCreature_some?: Maybe<EncounterCreatureWhereInput>;
  encounterCreature_none?: Maybe<EncounterCreatureWhereInput>;
  fifthLevelSpells?: Maybe<Int>;
  fifthLevelSpells_not?: Maybe<Int>;
  fifthLevelSpells_in?: Maybe<Int[] | Int>;
  fifthLevelSpells_not_in?: Maybe<Int[] | Int>;
  fifthLevelSpells_lt?: Maybe<Int>;
  fifthLevelSpells_lte?: Maybe<Int>;
  fifthLevelSpells_gt?: Maybe<Int>;
  fifthLevelSpells_gte?: Maybe<Int>;
  firstLevelSpells?: Maybe<Int>;
  firstLevelSpells_not?: Maybe<Int>;
  firstLevelSpells_in?: Maybe<Int[] | Int>;
  firstLevelSpells_not_in?: Maybe<Int[] | Int>;
  firstLevelSpells_lt?: Maybe<Int>;
  firstLevelSpells_lte?: Maybe<Int>;
  firstLevelSpells_gt?: Maybe<Int>;
  firstLevelSpells_gte?: Maybe<Int>;
  fourthLevelSpells?: Maybe<Int>;
  fourthLevelSpells_not?: Maybe<Int>;
  fourthLevelSpells_in?: Maybe<Int[] | Int>;
  fourthLevelSpells_not_in?: Maybe<Int[] | Int>;
  fourthLevelSpells_lt?: Maybe<Int>;
  fourthLevelSpells_lte?: Maybe<Int>;
  fourthLevelSpells_gt?: Maybe<Int>;
  fourthLevelSpells_gte?: Maybe<Int>;
  hitDiceNumber?: Maybe<Int>;
  hitDiceNumber_not?: Maybe<Int>;
  hitDiceNumber_in?: Maybe<Int[] | Int>;
  hitDiceNumber_not_in?: Maybe<Int[] | Int>;
  hitDiceNumber_lt?: Maybe<Int>;
  hitDiceNumber_lte?: Maybe<Int>;
  hitDiceNumber_gt?: Maybe<Int>;
  hitDiceNumber_gte?: Maybe<Int>;
  hitDiceType?: Maybe<Int>;
  hitDiceType_not?: Maybe<Int>;
  hitDiceType_in?: Maybe<Int[] | Int>;
  hitDiceType_not_in?: Maybe<Int[] | Int>;
  hitDiceType_lt?: Maybe<Int>;
  hitDiceType_lte?: Maybe<Int>;
  hitDiceType_gt?: Maybe<Int>;
  hitDiceType_gte?: Maybe<Int>;
  hitPointsAdd?: Maybe<Int>;
  hitPointsAdd_not?: Maybe<Int>;
  hitPointsAdd_in?: Maybe<Int[] | Int>;
  hitPointsAdd_not_in?: Maybe<Int[] | Int>;
  hitPointsAdd_lt?: Maybe<Int>;
  hitPointsAdd_lte?: Maybe<Int>;
  hitPointsAdd_gt?: Maybe<Int>;
  hitPointsAdd_gte?: Maybe<Int>;
  imageUrl?: Maybe<String>;
  imageUrl_not?: Maybe<String>;
  imageUrl_in?: Maybe<String[] | String>;
  imageUrl_not_in?: Maybe<String[] | String>;
  imageUrl_lt?: Maybe<String>;
  imageUrl_lte?: Maybe<String>;
  imageUrl_gt?: Maybe<String>;
  imageUrl_gte?: Maybe<String>;
  imageUrl_contains?: Maybe<String>;
  imageUrl_not_contains?: Maybe<String>;
  imageUrl_starts_with?: Maybe<String>;
  imageUrl_not_starts_with?: Maybe<String>;
  imageUrl_ends_with?: Maybe<String>;
  imageUrl_not_ends_with?: Maybe<String>;
  initiativeBonus?: Maybe<Int>;
  initiativeBonus_not?: Maybe<Int>;
  initiativeBonus_in?: Maybe<Int[] | Int>;
  initiativeBonus_not_in?: Maybe<Int[] | Int>;
  initiativeBonus_lt?: Maybe<Int>;
  initiativeBonus_lte?: Maybe<Int>;
  initiativeBonus_gt?: Maybe<Int>;
  initiativeBonus_gte?: Maybe<Int>;
  movementSpeed?: Maybe<Int>;
  movementSpeed_not?: Maybe<Int>;
  movementSpeed_in?: Maybe<Int[] | Int>;
  movementSpeed_not_in?: Maybe<Int[] | Int>;
  movementSpeed_lt?: Maybe<Int>;
  movementSpeed_lte?: Maybe<Int>;
  movementSpeed_gt?: Maybe<Int>;
  movementSpeed_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  ninthLevelSpells?: Maybe<Int>;
  ninthLevelSpells_not?: Maybe<Int>;
  ninthLevelSpells_in?: Maybe<Int[] | Int>;
  ninthLevelSpells_not_in?: Maybe<Int[] | Int>;
  ninthLevelSpells_lt?: Maybe<Int>;
  ninthLevelSpells_lte?: Maybe<Int>;
  ninthLevelSpells_gt?: Maybe<Int>;
  ninthLevelSpells_gte?: Maybe<Int>;
  secondAttackDiceType?: Maybe<Int>;
  secondAttackDiceType_not?: Maybe<Int>;
  secondAttackDiceType_in?: Maybe<Int[] | Int>;
  secondAttackDiceType_not_in?: Maybe<Int[] | Int>;
  secondAttackDiceType_lt?: Maybe<Int>;
  secondAttackDiceType_lte?: Maybe<Int>;
  secondAttackDiceType_gt?: Maybe<Int>;
  secondAttackDiceType_gte?: Maybe<Int>;
  secondAttackHitDieNumber?: Maybe<Int>;
  secondAttackHitDieNumber_not?: Maybe<Int>;
  secondAttackHitDieNumber_in?: Maybe<Int[] | Int>;
  secondAttackHitDieNumber_not_in?: Maybe<Int[] | Int>;
  secondAttackHitDieNumber_lt?: Maybe<Int>;
  secondAttackHitDieNumber_lte?: Maybe<Int>;
  secondAttackHitDieNumber_gt?: Maybe<Int>;
  secondAttackHitDieNumber_gte?: Maybe<Int>;
  secondAttackNameAndType?: Maybe<String>;
  secondAttackNameAndType_not?: Maybe<String>;
  secondAttackNameAndType_in?: Maybe<String[] | String>;
  secondAttackNameAndType_not_in?: Maybe<String[] | String>;
  secondAttackNameAndType_lt?: Maybe<String>;
  secondAttackNameAndType_lte?: Maybe<String>;
  secondAttackNameAndType_gt?: Maybe<String>;
  secondAttackNameAndType_gte?: Maybe<String>;
  secondAttackNameAndType_contains?: Maybe<String>;
  secondAttackNameAndType_not_contains?: Maybe<String>;
  secondAttackNameAndType_starts_with?: Maybe<String>;
  secondAttackNameAndType_not_starts_with?: Maybe<String>;
  secondAttackNameAndType_ends_with?: Maybe<String>;
  secondAttackNameAndType_not_ends_with?: Maybe<String>;
  secondAttackPointsAdd?: Maybe<Int>;
  secondAttackPointsAdd_not?: Maybe<Int>;
  secondAttackPointsAdd_in?: Maybe<Int[] | Int>;
  secondAttackPointsAdd_not_in?: Maybe<Int[] | Int>;
  secondAttackPointsAdd_lt?: Maybe<Int>;
  secondAttackPointsAdd_lte?: Maybe<Int>;
  secondAttackPointsAdd_gt?: Maybe<Int>;
  secondAttackPointsAdd_gte?: Maybe<Int>;
  secondLevelSpells?: Maybe<Int>;
  secondLevelSpells_not?: Maybe<Int>;
  secondLevelSpells_in?: Maybe<Int[] | Int>;
  secondLevelSpells_not_in?: Maybe<Int[] | Int>;
  secondLevelSpells_lt?: Maybe<Int>;
  secondLevelSpells_lte?: Maybe<Int>;
  secondLevelSpells_gt?: Maybe<Int>;
  secondLevelSpells_gte?: Maybe<Int>;
  secondToHitBonus?: Maybe<Int>;
  secondToHitBonus_not?: Maybe<Int>;
  secondToHitBonus_in?: Maybe<Int[] | Int>;
  secondToHitBonus_not_in?: Maybe<Int[] | Int>;
  secondToHitBonus_lt?: Maybe<Int>;
  secondToHitBonus_lte?: Maybe<Int>;
  secondToHitBonus_gt?: Maybe<Int>;
  secondToHitBonus_gte?: Maybe<Int>;
  seventhLevelSpells?: Maybe<Int>;
  seventhLevelSpells_not?: Maybe<Int>;
  seventhLevelSpells_in?: Maybe<Int[] | Int>;
  seventhLevelSpells_not_in?: Maybe<Int[] | Int>;
  seventhLevelSpells_lt?: Maybe<Int>;
  seventhLevelSpells_lte?: Maybe<Int>;
  seventhLevelSpells_gt?: Maybe<Int>;
  seventhLevelSpells_gte?: Maybe<Int>;
  sixthLevelSpells?: Maybe<Int>;
  sixthLevelSpells_not?: Maybe<Int>;
  sixthLevelSpells_in?: Maybe<Int[] | Int>;
  sixthLevelSpells_not_in?: Maybe<Int[] | Int>;
  sixthLevelSpells_lt?: Maybe<Int>;
  sixthLevelSpells_lte?: Maybe<Int>;
  sixthLevelSpells_gt?: Maybe<Int>;
  sixthLevelSpells_gte?: Maybe<Int>;
  spellAttack?: Maybe<Int>;
  spellAttack_not?: Maybe<Int>;
  spellAttack_in?: Maybe<Int[] | Int>;
  spellAttack_not_in?: Maybe<Int[] | Int>;
  spellAttack_lt?: Maybe<Int>;
  spellAttack_lte?: Maybe<Int>;
  spellAttack_gt?: Maybe<Int>;
  spellAttack_gte?: Maybe<Int>;
  spellSave?: Maybe<Int>;
  spellSave_not?: Maybe<Int>;
  spellSave_in?: Maybe<Int[] | Int>;
  spellSave_not_in?: Maybe<Int[] | Int>;
  spellSave_lt?: Maybe<Int>;
  spellSave_lte?: Maybe<Int>;
  spellSave_gt?: Maybe<Int>;
  spellSave_gte?: Maybe<Int>;
  thirdLevelSpells?: Maybe<Int>;
  thirdLevelSpells_not?: Maybe<Int>;
  thirdLevelSpells_in?: Maybe<Int[] | Int>;
  thirdLevelSpells_not_in?: Maybe<Int[] | Int>;
  thirdLevelSpells_lt?: Maybe<Int>;
  thirdLevelSpells_lte?: Maybe<Int>;
  thirdLevelSpells_gt?: Maybe<Int>;
  thirdLevelSpells_gte?: Maybe<Int>;
  toHitBonus?: Maybe<Int>;
  toHitBonus_not?: Maybe<Int>;
  toHitBonus_in?: Maybe<Int[] | Int>;
  toHitBonus_not_in?: Maybe<Int[] | Int>;
  toHitBonus_lt?: Maybe<Int>;
  toHitBonus_lte?: Maybe<Int>;
  toHitBonus_gt?: Maybe<Int>;
  toHitBonus_gte?: Maybe<Int>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CreatureWhereInput[] | CreatureWhereInput>;
  OR?: Maybe<CreatureWhereInput[] | CreatureWhereInput>;
  NOT?: Maybe<CreatureWhereInput[] | CreatureWhereInput>;
}

export interface PartyCreateManyWithoutSavedPartyIdInput {
  create?: Maybe<
    PartyCreateWithoutSavedPartyIdInput[] | PartyCreateWithoutSavedPartyIdInput
  >;
  connect?: Maybe<PartyWhereUniqueInput[] | PartyWhereUniqueInput>;
}

export interface PartySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PartyWhereInput>;
  AND?: Maybe<PartySubscriptionWhereInput[] | PartySubscriptionWhereInput>;
  OR?: Maybe<PartySubscriptionWhereInput[] | PartySubscriptionWhereInput>;
  NOT?: Maybe<PartySubscriptionWhereInput[] | PartySubscriptionWhereInput>;
}

export interface SavedPartyCreateInput {
  name: String;
  parties?: Maybe<PartyCreateManyWithoutSavedPartyIdInput>;
}

export interface EncounterSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EncounterWhereInput>;
  AND?: Maybe<
    EncounterSubscriptionWhereInput[] | EncounterSubscriptionWhereInput
  >;
  OR?: Maybe<
    EncounterSubscriptionWhereInput[] | EncounterSubscriptionWhereInput
  >;
  NOT?: Maybe<
    EncounterSubscriptionWhereInput[] | EncounterSubscriptionWhereInput
  >;
}

export interface PartyUpdateManyMutationInput {
  armorClass?: Maybe<Int>;
  attackDiceType?: Maybe<Int>;
  attackHitDieNumber?: Maybe<Int>;
  attackNameAndType?: Maybe<String>;
  attackPointsAdd?: Maybe<Int>;
  eighthLevelSpells?: Maybe<Int>;
  fifthLevelSpells?: Maybe<Int>;
  firstLevelSpells?: Maybe<Int>;
  fourthLevelSpells?: Maybe<Int>;
  hitDiceNumber?: Maybe<Int>;
  hitDiceType?: Maybe<Int>;
  hitPoints?: Maybe<Int>;
  hitPointsAdd?: Maybe<Int>;
  imageUrl?: Maybe<String>;
  initiativeBonus?: Maybe<Int>;
  movementSpeed?: Maybe<Int>;
  name?: Maybe<String>;
  ninthLevelSpells?: Maybe<Int>;
  secondAttackDiceType?: Maybe<Int>;
  secondAttackHitDieNumber?: Maybe<Int>;
  secondAttackNameAndType?: Maybe<String>;
  secondAttackPointsAdd?: Maybe<Int>;
  secondLevelSpells?: Maybe<Int>;
  secondToHitBonus?: Maybe<Int>;
  seventhLevelSpells?: Maybe<Int>;
  sixthLevelSpells?: Maybe<Int>;
  spellAttack?: Maybe<Int>;
  spellSave?: Maybe<Int>;
  thirdLevelSpells?: Maybe<Int>;
  toHitBonus?: Maybe<Int>;
}

export type EncounterWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type SavedPartyWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface EncounterWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  encounterCreature_every?: Maybe<EncounterCreatureWhereInput>;
  encounterCreature_some?: Maybe<EncounterCreatureWhereInput>;
  encounterCreature_none?: Maybe<EncounterCreatureWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<EncounterWhereInput[] | EncounterWhereInput>;
  OR?: Maybe<EncounterWhereInput[] | EncounterWhereInput>;
  NOT?: Maybe<EncounterWhereInput[] | EncounterWhereInput>;
}

export interface SavedPartyUpsertWithoutPartiesInput {
  update: SavedPartyUpdateWithoutPartiesDataInput;
  create: SavedPartyCreateWithoutPartiesInput;
}

export interface PartyUpdateManyDataInput {
  armorClass?: Maybe<Int>;
  attackDiceType?: Maybe<Int>;
  attackHitDieNumber?: Maybe<Int>;
  attackNameAndType?: Maybe<String>;
  attackPointsAdd?: Maybe<Int>;
  eighthLevelSpells?: Maybe<Int>;
  fifthLevelSpells?: Maybe<Int>;
  firstLevelSpells?: Maybe<Int>;
  fourthLevelSpells?: Maybe<Int>;
  hitDiceNumber?: Maybe<Int>;
  hitDiceType?: Maybe<Int>;
  hitPoints?: Maybe<Int>;
  hitPointsAdd?: Maybe<Int>;
  imageUrl?: Maybe<String>;
  initiativeBonus?: Maybe<Int>;
  movementSpeed?: Maybe<Int>;
  name?: Maybe<String>;
  ninthLevelSpells?: Maybe<Int>;
  secondAttackDiceType?: Maybe<Int>;
  secondAttackHitDieNumber?: Maybe<Int>;
  secondAttackNameAndType?: Maybe<String>;
  secondAttackPointsAdd?: Maybe<Int>;
  secondLevelSpells?: Maybe<Int>;
  secondToHitBonus?: Maybe<Int>;
  seventhLevelSpells?: Maybe<Int>;
  sixthLevelSpells?: Maybe<Int>;
  spellAttack?: Maybe<Int>;
  spellSave?: Maybe<Int>;
  thirdLevelSpells?: Maybe<Int>;
  toHitBonus?: Maybe<Int>;
}

export interface SavedPartyUpdateWithoutPartiesDataInput {
  name?: Maybe<String>;
}

export interface PartyScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  armorClass?: Maybe<Int>;
  armorClass_not?: Maybe<Int>;
  armorClass_in?: Maybe<Int[] | Int>;
  armorClass_not_in?: Maybe<Int[] | Int>;
  armorClass_lt?: Maybe<Int>;
  armorClass_lte?: Maybe<Int>;
  armorClass_gt?: Maybe<Int>;
  armorClass_gte?: Maybe<Int>;
  attackDiceType?: Maybe<Int>;
  attackDiceType_not?: Maybe<Int>;
  attackDiceType_in?: Maybe<Int[] | Int>;
  attackDiceType_not_in?: Maybe<Int[] | Int>;
  attackDiceType_lt?: Maybe<Int>;
  attackDiceType_lte?: Maybe<Int>;
  attackDiceType_gt?: Maybe<Int>;
  attackDiceType_gte?: Maybe<Int>;
  attackHitDieNumber?: Maybe<Int>;
  attackHitDieNumber_not?: Maybe<Int>;
  attackHitDieNumber_in?: Maybe<Int[] | Int>;
  attackHitDieNumber_not_in?: Maybe<Int[] | Int>;
  attackHitDieNumber_lt?: Maybe<Int>;
  attackHitDieNumber_lte?: Maybe<Int>;
  attackHitDieNumber_gt?: Maybe<Int>;
  attackHitDieNumber_gte?: Maybe<Int>;
  attackNameAndType?: Maybe<String>;
  attackNameAndType_not?: Maybe<String>;
  attackNameAndType_in?: Maybe<String[] | String>;
  attackNameAndType_not_in?: Maybe<String[] | String>;
  attackNameAndType_lt?: Maybe<String>;
  attackNameAndType_lte?: Maybe<String>;
  attackNameAndType_gt?: Maybe<String>;
  attackNameAndType_gte?: Maybe<String>;
  attackNameAndType_contains?: Maybe<String>;
  attackNameAndType_not_contains?: Maybe<String>;
  attackNameAndType_starts_with?: Maybe<String>;
  attackNameAndType_not_starts_with?: Maybe<String>;
  attackNameAndType_ends_with?: Maybe<String>;
  attackNameAndType_not_ends_with?: Maybe<String>;
  attackPointsAdd?: Maybe<Int>;
  attackPointsAdd_not?: Maybe<Int>;
  attackPointsAdd_in?: Maybe<Int[] | Int>;
  attackPointsAdd_not_in?: Maybe<Int[] | Int>;
  attackPointsAdd_lt?: Maybe<Int>;
  attackPointsAdd_lte?: Maybe<Int>;
  attackPointsAdd_gt?: Maybe<Int>;
  attackPointsAdd_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  eighthLevelSpells?: Maybe<Int>;
  eighthLevelSpells_not?: Maybe<Int>;
  eighthLevelSpells_in?: Maybe<Int[] | Int>;
  eighthLevelSpells_not_in?: Maybe<Int[] | Int>;
  eighthLevelSpells_lt?: Maybe<Int>;
  eighthLevelSpells_lte?: Maybe<Int>;
  eighthLevelSpells_gt?: Maybe<Int>;
  eighthLevelSpells_gte?: Maybe<Int>;
  fifthLevelSpells?: Maybe<Int>;
  fifthLevelSpells_not?: Maybe<Int>;
  fifthLevelSpells_in?: Maybe<Int[] | Int>;
  fifthLevelSpells_not_in?: Maybe<Int[] | Int>;
  fifthLevelSpells_lt?: Maybe<Int>;
  fifthLevelSpells_lte?: Maybe<Int>;
  fifthLevelSpells_gt?: Maybe<Int>;
  fifthLevelSpells_gte?: Maybe<Int>;
  firstLevelSpells?: Maybe<Int>;
  firstLevelSpells_not?: Maybe<Int>;
  firstLevelSpells_in?: Maybe<Int[] | Int>;
  firstLevelSpells_not_in?: Maybe<Int[] | Int>;
  firstLevelSpells_lt?: Maybe<Int>;
  firstLevelSpells_lte?: Maybe<Int>;
  firstLevelSpells_gt?: Maybe<Int>;
  firstLevelSpells_gte?: Maybe<Int>;
  fourthLevelSpells?: Maybe<Int>;
  fourthLevelSpells_not?: Maybe<Int>;
  fourthLevelSpells_in?: Maybe<Int[] | Int>;
  fourthLevelSpells_not_in?: Maybe<Int[] | Int>;
  fourthLevelSpells_lt?: Maybe<Int>;
  fourthLevelSpells_lte?: Maybe<Int>;
  fourthLevelSpells_gt?: Maybe<Int>;
  fourthLevelSpells_gte?: Maybe<Int>;
  hitDiceNumber?: Maybe<Int>;
  hitDiceNumber_not?: Maybe<Int>;
  hitDiceNumber_in?: Maybe<Int[] | Int>;
  hitDiceNumber_not_in?: Maybe<Int[] | Int>;
  hitDiceNumber_lt?: Maybe<Int>;
  hitDiceNumber_lte?: Maybe<Int>;
  hitDiceNumber_gt?: Maybe<Int>;
  hitDiceNumber_gte?: Maybe<Int>;
  hitDiceType?: Maybe<Int>;
  hitDiceType_not?: Maybe<Int>;
  hitDiceType_in?: Maybe<Int[] | Int>;
  hitDiceType_not_in?: Maybe<Int[] | Int>;
  hitDiceType_lt?: Maybe<Int>;
  hitDiceType_lte?: Maybe<Int>;
  hitDiceType_gt?: Maybe<Int>;
  hitDiceType_gte?: Maybe<Int>;
  hitPoints?: Maybe<Int>;
  hitPoints_not?: Maybe<Int>;
  hitPoints_in?: Maybe<Int[] | Int>;
  hitPoints_not_in?: Maybe<Int[] | Int>;
  hitPoints_lt?: Maybe<Int>;
  hitPoints_lte?: Maybe<Int>;
  hitPoints_gt?: Maybe<Int>;
  hitPoints_gte?: Maybe<Int>;
  hitPointsAdd?: Maybe<Int>;
  hitPointsAdd_not?: Maybe<Int>;
  hitPointsAdd_in?: Maybe<Int[] | Int>;
  hitPointsAdd_not_in?: Maybe<Int[] | Int>;
  hitPointsAdd_lt?: Maybe<Int>;
  hitPointsAdd_lte?: Maybe<Int>;
  hitPointsAdd_gt?: Maybe<Int>;
  hitPointsAdd_gte?: Maybe<Int>;
  imageUrl?: Maybe<String>;
  imageUrl_not?: Maybe<String>;
  imageUrl_in?: Maybe<String[] | String>;
  imageUrl_not_in?: Maybe<String[] | String>;
  imageUrl_lt?: Maybe<String>;
  imageUrl_lte?: Maybe<String>;
  imageUrl_gt?: Maybe<String>;
  imageUrl_gte?: Maybe<String>;
  imageUrl_contains?: Maybe<String>;
  imageUrl_not_contains?: Maybe<String>;
  imageUrl_starts_with?: Maybe<String>;
  imageUrl_not_starts_with?: Maybe<String>;
  imageUrl_ends_with?: Maybe<String>;
  imageUrl_not_ends_with?: Maybe<String>;
  initiativeBonus?: Maybe<Int>;
  initiativeBonus_not?: Maybe<Int>;
  initiativeBonus_in?: Maybe<Int[] | Int>;
  initiativeBonus_not_in?: Maybe<Int[] | Int>;
  initiativeBonus_lt?: Maybe<Int>;
  initiativeBonus_lte?: Maybe<Int>;
  initiativeBonus_gt?: Maybe<Int>;
  initiativeBonus_gte?: Maybe<Int>;
  movementSpeed?: Maybe<Int>;
  movementSpeed_not?: Maybe<Int>;
  movementSpeed_in?: Maybe<Int[] | Int>;
  movementSpeed_not_in?: Maybe<Int[] | Int>;
  movementSpeed_lt?: Maybe<Int>;
  movementSpeed_lte?: Maybe<Int>;
  movementSpeed_gt?: Maybe<Int>;
  movementSpeed_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  ninthLevelSpells?: Maybe<Int>;
  ninthLevelSpells_not?: Maybe<Int>;
  ninthLevelSpells_in?: Maybe<Int[] | Int>;
  ninthLevelSpells_not_in?: Maybe<Int[] | Int>;
  ninthLevelSpells_lt?: Maybe<Int>;
  ninthLevelSpells_lte?: Maybe<Int>;
  ninthLevelSpells_gt?: Maybe<Int>;
  ninthLevelSpells_gte?: Maybe<Int>;
  secondAttackDiceType?: Maybe<Int>;
  secondAttackDiceType_not?: Maybe<Int>;
  secondAttackDiceType_in?: Maybe<Int[] | Int>;
  secondAttackDiceType_not_in?: Maybe<Int[] | Int>;
  secondAttackDiceType_lt?: Maybe<Int>;
  secondAttackDiceType_lte?: Maybe<Int>;
  secondAttackDiceType_gt?: Maybe<Int>;
  secondAttackDiceType_gte?: Maybe<Int>;
  secondAttackHitDieNumber?: Maybe<Int>;
  secondAttackHitDieNumber_not?: Maybe<Int>;
  secondAttackHitDieNumber_in?: Maybe<Int[] | Int>;
  secondAttackHitDieNumber_not_in?: Maybe<Int[] | Int>;
  secondAttackHitDieNumber_lt?: Maybe<Int>;
  secondAttackHitDieNumber_lte?: Maybe<Int>;
  secondAttackHitDieNumber_gt?: Maybe<Int>;
  secondAttackHitDieNumber_gte?: Maybe<Int>;
  secondAttackNameAndType?: Maybe<String>;
  secondAttackNameAndType_not?: Maybe<String>;
  secondAttackNameAndType_in?: Maybe<String[] | String>;
  secondAttackNameAndType_not_in?: Maybe<String[] | String>;
  secondAttackNameAndType_lt?: Maybe<String>;
  secondAttackNameAndType_lte?: Maybe<String>;
  secondAttackNameAndType_gt?: Maybe<String>;
  secondAttackNameAndType_gte?: Maybe<String>;
  secondAttackNameAndType_contains?: Maybe<String>;
  secondAttackNameAndType_not_contains?: Maybe<String>;
  secondAttackNameAndType_starts_with?: Maybe<String>;
  secondAttackNameAndType_not_starts_with?: Maybe<String>;
  secondAttackNameAndType_ends_with?: Maybe<String>;
  secondAttackNameAndType_not_ends_with?: Maybe<String>;
  secondAttackPointsAdd?: Maybe<Int>;
  secondAttackPointsAdd_not?: Maybe<Int>;
  secondAttackPointsAdd_in?: Maybe<Int[] | Int>;
  secondAttackPointsAdd_not_in?: Maybe<Int[] | Int>;
  secondAttackPointsAdd_lt?: Maybe<Int>;
  secondAttackPointsAdd_lte?: Maybe<Int>;
  secondAttackPointsAdd_gt?: Maybe<Int>;
  secondAttackPointsAdd_gte?: Maybe<Int>;
  secondLevelSpells?: Maybe<Int>;
  secondLevelSpells_not?: Maybe<Int>;
  secondLevelSpells_in?: Maybe<Int[] | Int>;
  secondLevelSpells_not_in?: Maybe<Int[] | Int>;
  secondLevelSpells_lt?: Maybe<Int>;
  secondLevelSpells_lte?: Maybe<Int>;
  secondLevelSpells_gt?: Maybe<Int>;
  secondLevelSpells_gte?: Maybe<Int>;
  secondToHitBonus?: Maybe<Int>;
  secondToHitBonus_not?: Maybe<Int>;
  secondToHitBonus_in?: Maybe<Int[] | Int>;
  secondToHitBonus_not_in?: Maybe<Int[] | Int>;
  secondToHitBonus_lt?: Maybe<Int>;
  secondToHitBonus_lte?: Maybe<Int>;
  secondToHitBonus_gt?: Maybe<Int>;
  secondToHitBonus_gte?: Maybe<Int>;
  seventhLevelSpells?: Maybe<Int>;
  seventhLevelSpells_not?: Maybe<Int>;
  seventhLevelSpells_in?: Maybe<Int[] | Int>;
  seventhLevelSpells_not_in?: Maybe<Int[] | Int>;
  seventhLevelSpells_lt?: Maybe<Int>;
  seventhLevelSpells_lte?: Maybe<Int>;
  seventhLevelSpells_gt?: Maybe<Int>;
  seventhLevelSpells_gte?: Maybe<Int>;
  sixthLevelSpells?: Maybe<Int>;
  sixthLevelSpells_not?: Maybe<Int>;
  sixthLevelSpells_in?: Maybe<Int[] | Int>;
  sixthLevelSpells_not_in?: Maybe<Int[] | Int>;
  sixthLevelSpells_lt?: Maybe<Int>;
  sixthLevelSpells_lte?: Maybe<Int>;
  sixthLevelSpells_gt?: Maybe<Int>;
  sixthLevelSpells_gte?: Maybe<Int>;
  spellAttack?: Maybe<Int>;
  spellAttack_not?: Maybe<Int>;
  spellAttack_in?: Maybe<Int[] | Int>;
  spellAttack_not_in?: Maybe<Int[] | Int>;
  spellAttack_lt?: Maybe<Int>;
  spellAttack_lte?: Maybe<Int>;
  spellAttack_gt?: Maybe<Int>;
  spellAttack_gte?: Maybe<Int>;
  spellSave?: Maybe<Int>;
  spellSave_not?: Maybe<Int>;
  spellSave_in?: Maybe<Int[] | Int>;
  spellSave_not_in?: Maybe<Int[] | Int>;
  spellSave_lt?: Maybe<Int>;
  spellSave_lte?: Maybe<Int>;
  spellSave_gt?: Maybe<Int>;
  spellSave_gte?: Maybe<Int>;
  thirdLevelSpells?: Maybe<Int>;
  thirdLevelSpells_not?: Maybe<Int>;
  thirdLevelSpells_in?: Maybe<Int[] | Int>;
  thirdLevelSpells_not_in?: Maybe<Int[] | Int>;
  thirdLevelSpells_lt?: Maybe<Int>;
  thirdLevelSpells_lte?: Maybe<Int>;
  thirdLevelSpells_gt?: Maybe<Int>;
  thirdLevelSpells_gte?: Maybe<Int>;
  toHitBonus?: Maybe<Int>;
  toHitBonus_not?: Maybe<Int>;
  toHitBonus_in?: Maybe<Int[] | Int>;
  toHitBonus_not_in?: Maybe<Int[] | Int>;
  toHitBonus_lt?: Maybe<Int>;
  toHitBonus_lte?: Maybe<Int>;
  toHitBonus_gt?: Maybe<Int>;
  toHitBonus_gte?: Maybe<Int>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PartyScalarWhereInput[] | PartyScalarWhereInput>;
  OR?: Maybe<PartyScalarWhereInput[] | PartyScalarWhereInput>;
  NOT?: Maybe<PartyScalarWhereInput[] | PartyScalarWhereInput>;
}

export interface SavedPartyUpdateOneWithoutPartiesInput {
  create?: Maybe<SavedPartyCreateWithoutPartiesInput>;
  update?: Maybe<SavedPartyUpdateWithoutPartiesDataInput>;
  upsert?: Maybe<SavedPartyUpsertWithoutPartiesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<SavedPartyWhereUniqueInput>;
}

export interface PartyUpdateWithoutSavedPartyIdDataInput {
  armorClass?: Maybe<Int>;
  attackDiceType?: Maybe<Int>;
  attackHitDieNumber?: Maybe<Int>;
  attackNameAndType?: Maybe<String>;
  attackPointsAdd?: Maybe<Int>;
  eighthLevelSpells?: Maybe<Int>;
  fifthLevelSpells?: Maybe<Int>;
  firstLevelSpells?: Maybe<Int>;
  fourthLevelSpells?: Maybe<Int>;
  hitDiceNumber?: Maybe<Int>;
  hitDiceType?: Maybe<Int>;
  hitPoints?: Maybe<Int>;
  hitPointsAdd?: Maybe<Int>;
  imageUrl?: Maybe<String>;
  initiativeBonus?: Maybe<Int>;
  movementSpeed?: Maybe<Int>;
  name?: Maybe<String>;
  ninthLevelSpells?: Maybe<Int>;
  secondAttackDiceType?: Maybe<Int>;
  secondAttackHitDieNumber?: Maybe<Int>;
  secondAttackNameAndType?: Maybe<String>;
  secondAttackPointsAdd?: Maybe<Int>;
  secondLevelSpells?: Maybe<Int>;
  secondToHitBonus?: Maybe<Int>;
  seventhLevelSpells?: Maybe<Int>;
  sixthLevelSpells?: Maybe<Int>;
  spellAttack?: Maybe<Int>;
  spellSave?: Maybe<Int>;
  thirdLevelSpells?: Maybe<Int>;
  toHitBonus?: Maybe<Int>;
}

export interface PartyUpdateInput {
  armorClass?: Maybe<Int>;
  attackDiceType?: Maybe<Int>;
  attackHitDieNumber?: Maybe<Int>;
  attackNameAndType?: Maybe<String>;
  attackPointsAdd?: Maybe<Int>;
  eighthLevelSpells?: Maybe<Int>;
  fifthLevelSpells?: Maybe<Int>;
  firstLevelSpells?: Maybe<Int>;
  fourthLevelSpells?: Maybe<Int>;
  hitDiceNumber?: Maybe<Int>;
  hitDiceType?: Maybe<Int>;
  hitPoints?: Maybe<Int>;
  hitPointsAdd?: Maybe<Int>;
  imageUrl?: Maybe<String>;
  initiativeBonus?: Maybe<Int>;
  movementSpeed?: Maybe<Int>;
  name?: Maybe<String>;
  ninthLevelSpells?: Maybe<Int>;
  savedPartyId?: Maybe<SavedPartyUpdateOneWithoutPartiesInput>;
  secondAttackDiceType?: Maybe<Int>;
  secondAttackHitDieNumber?: Maybe<Int>;
  secondAttackNameAndType?: Maybe<String>;
  secondAttackPointsAdd?: Maybe<Int>;
  secondLevelSpells?: Maybe<Int>;
  secondToHitBonus?: Maybe<Int>;
  seventhLevelSpells?: Maybe<Int>;
  sixthLevelSpells?: Maybe<Int>;
  spellAttack?: Maybe<Int>;
  spellSave?: Maybe<Int>;
  thirdLevelSpells?: Maybe<Int>;
  toHitBonus?: Maybe<Int>;
}

export type PartyWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface SavedPartyCreateWithoutPartiesInput {
  name: String;
}

export interface SavedPartyUpdateInput {
  name?: Maybe<String>;
  parties?: Maybe<PartyUpdateManyWithoutSavedPartyIdInput>;
}

export interface SavedPartySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SavedPartyWhereInput>;
  AND?: Maybe<
    SavedPartySubscriptionWhereInput[] | SavedPartySubscriptionWhereInput
  >;
  OR?: Maybe<
    SavedPartySubscriptionWhereInput[] | SavedPartySubscriptionWhereInput
  >;
  NOT?: Maybe<
    SavedPartySubscriptionWhereInput[] | SavedPartySubscriptionWhereInput
  >;
}

export interface CreatureSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CreatureWhereInput>;
  AND?: Maybe<
    CreatureSubscriptionWhereInput[] | CreatureSubscriptionWhereInput
  >;
  OR?: Maybe<CreatureSubscriptionWhereInput[] | CreatureSubscriptionWhereInput>;
  NOT?: Maybe<
    CreatureSubscriptionWhereInput[] | CreatureSubscriptionWhereInput
  >;
}

export interface CreatureCreateInput {
  armorClass?: Maybe<Int>;
  attackDiceType?: Maybe<Int>;
  attackHitDieNumber?: Maybe<Int>;
  attackNameAndType?: Maybe<String>;
  attackPointsAdd?: Maybe<Int>;
  eighthLevelSpells?: Maybe<Int>;
  fifthLevelSpells?: Maybe<Int>;
  firstLevelSpells?: Maybe<Int>;
  fourthLevelSpells?: Maybe<Int>;
  hitDiceNumber?: Maybe<Int>;
  hitDiceType?: Maybe<Int>;
  hitPointsAdd?: Maybe<Int>;
  imageUrl?: Maybe<String>;
  initiativeBonus?: Maybe<Int>;
  movementSpeed?: Maybe<Int>;
  name: String;
  ninthLevelSpells?: Maybe<Int>;
  secondAttackDiceType?: Maybe<Int>;
  secondAttackHitDieNumber?: Maybe<Int>;
  secondAttackNameAndType?: Maybe<String>;
  secondAttackPointsAdd?: Maybe<Int>;
  secondLevelSpells?: Maybe<Int>;
  secondToHitBonus?: Maybe<Int>;
  seventhLevelSpells?: Maybe<Int>;
  sixthLevelSpells?: Maybe<Int>;
  spellAttack?: Maybe<Int>;
  spellSave?: Maybe<Int>;
  thirdLevelSpells?: Maybe<Int>;
  toHitBonus?: Maybe<Int>;
}

export interface EncounterCreatureWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<EncounterCreatureWhereInput[] | EncounterCreatureWhereInput>;
  OR?: Maybe<EncounterCreatureWhereInput[] | EncounterCreatureWhereInput>;
  NOT?: Maybe<EncounterCreatureWhereInput[] | EncounterCreatureWhereInput>;
}

export interface CreatureUpdateInput {
  armorClass?: Maybe<Int>;
  attackDiceType?: Maybe<Int>;
  attackHitDieNumber?: Maybe<Int>;
  attackNameAndType?: Maybe<String>;
  attackPointsAdd?: Maybe<Int>;
  eighthLevelSpells?: Maybe<Int>;
  encounterCreature?: Maybe<EncounterCreatureUpdateManyInput>;
  fifthLevelSpells?: Maybe<Int>;
  firstLevelSpells?: Maybe<Int>;
  fourthLevelSpells?: Maybe<Int>;
  hitDiceNumber?: Maybe<Int>;
  hitDiceType?: Maybe<Int>;
  hitPointsAdd?: Maybe<Int>;
  imageUrl?: Maybe<String>;
  initiativeBonus?: Maybe<Int>;
  movementSpeed?: Maybe<Int>;
  name?: Maybe<String>;
  ninthLevelSpells?: Maybe<Int>;
  secondAttackDiceType?: Maybe<Int>;
  secondAttackHitDieNumber?: Maybe<Int>;
  secondAttackNameAndType?: Maybe<String>;
  secondAttackPointsAdd?: Maybe<Int>;
  secondLevelSpells?: Maybe<Int>;
  secondToHitBonus?: Maybe<Int>;
  seventhLevelSpells?: Maybe<Int>;
  sixthLevelSpells?: Maybe<Int>;
  spellAttack?: Maybe<Int>;
  spellSave?: Maybe<Int>;
  thirdLevelSpells?: Maybe<Int>;
  toHitBonus?: Maybe<Int>;
}

export interface PartyUpsertWithWhereUniqueWithoutSavedPartyIdInput {
  where: PartyWhereUniqueInput;
  update: PartyUpdateWithoutSavedPartyIdDataInput;
  create: PartyCreateWithoutSavedPartyIdInput;
}

export interface SavedPartyCreateOneWithoutPartiesInput {
  create?: Maybe<SavedPartyCreateWithoutPartiesInput>;
  connect?: Maybe<SavedPartyWhereUniqueInput>;
}

export interface PartyUpdateManyWithoutSavedPartyIdInput {
  create?: Maybe<
    PartyCreateWithoutSavedPartyIdInput[] | PartyCreateWithoutSavedPartyIdInput
  >;
  delete?: Maybe<PartyWhereUniqueInput[] | PartyWhereUniqueInput>;
  connect?: Maybe<PartyWhereUniqueInput[] | PartyWhereUniqueInput>;
  set?: Maybe<PartyWhereUniqueInput[] | PartyWhereUniqueInput>;
  disconnect?: Maybe<PartyWhereUniqueInput[] | PartyWhereUniqueInput>;
  update?: Maybe<
    | PartyUpdateWithWhereUniqueWithoutSavedPartyIdInput[]
    | PartyUpdateWithWhereUniqueWithoutSavedPartyIdInput
  >;
  upsert?: Maybe<
    | PartyUpsertWithWhereUniqueWithoutSavedPartyIdInput[]
    | PartyUpsertWithWhereUniqueWithoutSavedPartyIdInput
  >;
  deleteMany?: Maybe<PartyScalarWhereInput[] | PartyScalarWhereInput>;
  updateMany?: Maybe<
    PartyUpdateManyWithWhereNestedInput[] | PartyUpdateManyWithWhereNestedInput
  >;
}

export interface EncounterCreatureScalarWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    EncounterCreatureScalarWhereInput[] | EncounterCreatureScalarWhereInput
  >;
  OR?: Maybe<
    EncounterCreatureScalarWhereInput[] | EncounterCreatureScalarWhereInput
  >;
  NOT?: Maybe<
    EncounterCreatureScalarWhereInput[] | EncounterCreatureScalarWhereInput
  >;
}

export interface EncounterCreatureSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EncounterCreatureWhereInput>;
  AND?: Maybe<
    | EncounterCreatureSubscriptionWhereInput[]
    | EncounterCreatureSubscriptionWhereInput
  >;
  OR?: Maybe<
    | EncounterCreatureSubscriptionWhereInput[]
    | EncounterCreatureSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | EncounterCreatureSubscriptionWhereInput[]
    | EncounterCreatureSubscriptionWhereInput
  >;
}

export interface EncounterCreateInput {
  name: String;
}

export interface EncounterUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface PartyCreateInput {
  armorClass?: Maybe<Int>;
  attackDiceType?: Maybe<Int>;
  attackHitDieNumber?: Maybe<Int>;
  attackNameAndType?: Maybe<String>;
  attackPointsAdd?: Maybe<Int>;
  eighthLevelSpells?: Maybe<Int>;
  fifthLevelSpells?: Maybe<Int>;
  firstLevelSpells?: Maybe<Int>;
  fourthLevelSpells?: Maybe<Int>;
  hitDiceNumber?: Maybe<Int>;
  hitDiceType?: Maybe<Int>;
  hitPoints?: Maybe<Int>;
  hitPointsAdd?: Maybe<Int>;
  imageUrl?: Maybe<String>;
  initiativeBonus?: Maybe<Int>;
  movementSpeed?: Maybe<Int>;
  name: String;
  ninthLevelSpells?: Maybe<Int>;
  savedPartyId?: Maybe<SavedPartyCreateOneWithoutPartiesInput>;
  secondAttackDiceType?: Maybe<Int>;
  secondAttackHitDieNumber?: Maybe<Int>;
  secondAttackNameAndType?: Maybe<String>;
  secondAttackPointsAdd?: Maybe<Int>;
  secondLevelSpells?: Maybe<Int>;
  secondToHitBonus?: Maybe<Int>;
  seventhLevelSpells?: Maybe<Int>;
  sixthLevelSpells?: Maybe<Int>;
  spellAttack?: Maybe<Int>;
  spellSave?: Maybe<Int>;
  thirdLevelSpells?: Maybe<Int>;
  toHitBonus?: Maybe<Int>;
}

export interface CreatureUpdateManyMutationInput {
  armorClass?: Maybe<Int>;
  attackDiceType?: Maybe<Int>;
  attackHitDieNumber?: Maybe<Int>;
  attackNameAndType?: Maybe<String>;
  attackPointsAdd?: Maybe<Int>;
  eighthLevelSpells?: Maybe<Int>;
  fifthLevelSpells?: Maybe<Int>;
  firstLevelSpells?: Maybe<Int>;
  fourthLevelSpells?: Maybe<Int>;
  hitDiceNumber?: Maybe<Int>;
  hitDiceType?: Maybe<Int>;
  hitPointsAdd?: Maybe<Int>;
  imageUrl?: Maybe<String>;
  initiativeBonus?: Maybe<Int>;
  movementSpeed?: Maybe<Int>;
  name?: Maybe<String>;
  ninthLevelSpells?: Maybe<Int>;
  secondAttackDiceType?: Maybe<Int>;
  secondAttackHitDieNumber?: Maybe<Int>;
  secondAttackNameAndType?: Maybe<String>;
  secondAttackPointsAdd?: Maybe<Int>;
  secondLevelSpells?: Maybe<Int>;
  secondToHitBonus?: Maybe<Int>;
  seventhLevelSpells?: Maybe<Int>;
  sixthLevelSpells?: Maybe<Int>;
  spellAttack?: Maybe<Int>;
  spellSave?: Maybe<Int>;
  thirdLevelSpells?: Maybe<Int>;
  toHitBonus?: Maybe<Int>;
}

export interface SavedPartyUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface PartyWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  armorClass?: Maybe<Int>;
  armorClass_not?: Maybe<Int>;
  armorClass_in?: Maybe<Int[] | Int>;
  armorClass_not_in?: Maybe<Int[] | Int>;
  armorClass_lt?: Maybe<Int>;
  armorClass_lte?: Maybe<Int>;
  armorClass_gt?: Maybe<Int>;
  armorClass_gte?: Maybe<Int>;
  attackDiceType?: Maybe<Int>;
  attackDiceType_not?: Maybe<Int>;
  attackDiceType_in?: Maybe<Int[] | Int>;
  attackDiceType_not_in?: Maybe<Int[] | Int>;
  attackDiceType_lt?: Maybe<Int>;
  attackDiceType_lte?: Maybe<Int>;
  attackDiceType_gt?: Maybe<Int>;
  attackDiceType_gte?: Maybe<Int>;
  attackHitDieNumber?: Maybe<Int>;
  attackHitDieNumber_not?: Maybe<Int>;
  attackHitDieNumber_in?: Maybe<Int[] | Int>;
  attackHitDieNumber_not_in?: Maybe<Int[] | Int>;
  attackHitDieNumber_lt?: Maybe<Int>;
  attackHitDieNumber_lte?: Maybe<Int>;
  attackHitDieNumber_gt?: Maybe<Int>;
  attackHitDieNumber_gte?: Maybe<Int>;
  attackNameAndType?: Maybe<String>;
  attackNameAndType_not?: Maybe<String>;
  attackNameAndType_in?: Maybe<String[] | String>;
  attackNameAndType_not_in?: Maybe<String[] | String>;
  attackNameAndType_lt?: Maybe<String>;
  attackNameAndType_lte?: Maybe<String>;
  attackNameAndType_gt?: Maybe<String>;
  attackNameAndType_gte?: Maybe<String>;
  attackNameAndType_contains?: Maybe<String>;
  attackNameAndType_not_contains?: Maybe<String>;
  attackNameAndType_starts_with?: Maybe<String>;
  attackNameAndType_not_starts_with?: Maybe<String>;
  attackNameAndType_ends_with?: Maybe<String>;
  attackNameAndType_not_ends_with?: Maybe<String>;
  attackPointsAdd?: Maybe<Int>;
  attackPointsAdd_not?: Maybe<Int>;
  attackPointsAdd_in?: Maybe<Int[] | Int>;
  attackPointsAdd_not_in?: Maybe<Int[] | Int>;
  attackPointsAdd_lt?: Maybe<Int>;
  attackPointsAdd_lte?: Maybe<Int>;
  attackPointsAdd_gt?: Maybe<Int>;
  attackPointsAdd_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  eighthLevelSpells?: Maybe<Int>;
  eighthLevelSpells_not?: Maybe<Int>;
  eighthLevelSpells_in?: Maybe<Int[] | Int>;
  eighthLevelSpells_not_in?: Maybe<Int[] | Int>;
  eighthLevelSpells_lt?: Maybe<Int>;
  eighthLevelSpells_lte?: Maybe<Int>;
  eighthLevelSpells_gt?: Maybe<Int>;
  eighthLevelSpells_gte?: Maybe<Int>;
  fifthLevelSpells?: Maybe<Int>;
  fifthLevelSpells_not?: Maybe<Int>;
  fifthLevelSpells_in?: Maybe<Int[] | Int>;
  fifthLevelSpells_not_in?: Maybe<Int[] | Int>;
  fifthLevelSpells_lt?: Maybe<Int>;
  fifthLevelSpells_lte?: Maybe<Int>;
  fifthLevelSpells_gt?: Maybe<Int>;
  fifthLevelSpells_gte?: Maybe<Int>;
  firstLevelSpells?: Maybe<Int>;
  firstLevelSpells_not?: Maybe<Int>;
  firstLevelSpells_in?: Maybe<Int[] | Int>;
  firstLevelSpells_not_in?: Maybe<Int[] | Int>;
  firstLevelSpells_lt?: Maybe<Int>;
  firstLevelSpells_lte?: Maybe<Int>;
  firstLevelSpells_gt?: Maybe<Int>;
  firstLevelSpells_gte?: Maybe<Int>;
  fourthLevelSpells?: Maybe<Int>;
  fourthLevelSpells_not?: Maybe<Int>;
  fourthLevelSpells_in?: Maybe<Int[] | Int>;
  fourthLevelSpells_not_in?: Maybe<Int[] | Int>;
  fourthLevelSpells_lt?: Maybe<Int>;
  fourthLevelSpells_lte?: Maybe<Int>;
  fourthLevelSpells_gt?: Maybe<Int>;
  fourthLevelSpells_gte?: Maybe<Int>;
  hitDiceNumber?: Maybe<Int>;
  hitDiceNumber_not?: Maybe<Int>;
  hitDiceNumber_in?: Maybe<Int[] | Int>;
  hitDiceNumber_not_in?: Maybe<Int[] | Int>;
  hitDiceNumber_lt?: Maybe<Int>;
  hitDiceNumber_lte?: Maybe<Int>;
  hitDiceNumber_gt?: Maybe<Int>;
  hitDiceNumber_gte?: Maybe<Int>;
  hitDiceType?: Maybe<Int>;
  hitDiceType_not?: Maybe<Int>;
  hitDiceType_in?: Maybe<Int[] | Int>;
  hitDiceType_not_in?: Maybe<Int[] | Int>;
  hitDiceType_lt?: Maybe<Int>;
  hitDiceType_lte?: Maybe<Int>;
  hitDiceType_gt?: Maybe<Int>;
  hitDiceType_gte?: Maybe<Int>;
  hitPoints?: Maybe<Int>;
  hitPoints_not?: Maybe<Int>;
  hitPoints_in?: Maybe<Int[] | Int>;
  hitPoints_not_in?: Maybe<Int[] | Int>;
  hitPoints_lt?: Maybe<Int>;
  hitPoints_lte?: Maybe<Int>;
  hitPoints_gt?: Maybe<Int>;
  hitPoints_gte?: Maybe<Int>;
  hitPointsAdd?: Maybe<Int>;
  hitPointsAdd_not?: Maybe<Int>;
  hitPointsAdd_in?: Maybe<Int[] | Int>;
  hitPointsAdd_not_in?: Maybe<Int[] | Int>;
  hitPointsAdd_lt?: Maybe<Int>;
  hitPointsAdd_lte?: Maybe<Int>;
  hitPointsAdd_gt?: Maybe<Int>;
  hitPointsAdd_gte?: Maybe<Int>;
  imageUrl?: Maybe<String>;
  imageUrl_not?: Maybe<String>;
  imageUrl_in?: Maybe<String[] | String>;
  imageUrl_not_in?: Maybe<String[] | String>;
  imageUrl_lt?: Maybe<String>;
  imageUrl_lte?: Maybe<String>;
  imageUrl_gt?: Maybe<String>;
  imageUrl_gte?: Maybe<String>;
  imageUrl_contains?: Maybe<String>;
  imageUrl_not_contains?: Maybe<String>;
  imageUrl_starts_with?: Maybe<String>;
  imageUrl_not_starts_with?: Maybe<String>;
  imageUrl_ends_with?: Maybe<String>;
  imageUrl_not_ends_with?: Maybe<String>;
  initiativeBonus?: Maybe<Int>;
  initiativeBonus_not?: Maybe<Int>;
  initiativeBonus_in?: Maybe<Int[] | Int>;
  initiativeBonus_not_in?: Maybe<Int[] | Int>;
  initiativeBonus_lt?: Maybe<Int>;
  initiativeBonus_lte?: Maybe<Int>;
  initiativeBonus_gt?: Maybe<Int>;
  initiativeBonus_gte?: Maybe<Int>;
  movementSpeed?: Maybe<Int>;
  movementSpeed_not?: Maybe<Int>;
  movementSpeed_in?: Maybe<Int[] | Int>;
  movementSpeed_not_in?: Maybe<Int[] | Int>;
  movementSpeed_lt?: Maybe<Int>;
  movementSpeed_lte?: Maybe<Int>;
  movementSpeed_gt?: Maybe<Int>;
  movementSpeed_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  ninthLevelSpells?: Maybe<Int>;
  ninthLevelSpells_not?: Maybe<Int>;
  ninthLevelSpells_in?: Maybe<Int[] | Int>;
  ninthLevelSpells_not_in?: Maybe<Int[] | Int>;
  ninthLevelSpells_lt?: Maybe<Int>;
  ninthLevelSpells_lte?: Maybe<Int>;
  ninthLevelSpells_gt?: Maybe<Int>;
  ninthLevelSpells_gte?: Maybe<Int>;
  savedPartyId?: Maybe<SavedPartyWhereInput>;
  secondAttackDiceType?: Maybe<Int>;
  secondAttackDiceType_not?: Maybe<Int>;
  secondAttackDiceType_in?: Maybe<Int[] | Int>;
  secondAttackDiceType_not_in?: Maybe<Int[] | Int>;
  secondAttackDiceType_lt?: Maybe<Int>;
  secondAttackDiceType_lte?: Maybe<Int>;
  secondAttackDiceType_gt?: Maybe<Int>;
  secondAttackDiceType_gte?: Maybe<Int>;
  secondAttackHitDieNumber?: Maybe<Int>;
  secondAttackHitDieNumber_not?: Maybe<Int>;
  secondAttackHitDieNumber_in?: Maybe<Int[] | Int>;
  secondAttackHitDieNumber_not_in?: Maybe<Int[] | Int>;
  secondAttackHitDieNumber_lt?: Maybe<Int>;
  secondAttackHitDieNumber_lte?: Maybe<Int>;
  secondAttackHitDieNumber_gt?: Maybe<Int>;
  secondAttackHitDieNumber_gte?: Maybe<Int>;
  secondAttackNameAndType?: Maybe<String>;
  secondAttackNameAndType_not?: Maybe<String>;
  secondAttackNameAndType_in?: Maybe<String[] | String>;
  secondAttackNameAndType_not_in?: Maybe<String[] | String>;
  secondAttackNameAndType_lt?: Maybe<String>;
  secondAttackNameAndType_lte?: Maybe<String>;
  secondAttackNameAndType_gt?: Maybe<String>;
  secondAttackNameAndType_gte?: Maybe<String>;
  secondAttackNameAndType_contains?: Maybe<String>;
  secondAttackNameAndType_not_contains?: Maybe<String>;
  secondAttackNameAndType_starts_with?: Maybe<String>;
  secondAttackNameAndType_not_starts_with?: Maybe<String>;
  secondAttackNameAndType_ends_with?: Maybe<String>;
  secondAttackNameAndType_not_ends_with?: Maybe<String>;
  secondAttackPointsAdd?: Maybe<Int>;
  secondAttackPointsAdd_not?: Maybe<Int>;
  secondAttackPointsAdd_in?: Maybe<Int[] | Int>;
  secondAttackPointsAdd_not_in?: Maybe<Int[] | Int>;
  secondAttackPointsAdd_lt?: Maybe<Int>;
  secondAttackPointsAdd_lte?: Maybe<Int>;
  secondAttackPointsAdd_gt?: Maybe<Int>;
  secondAttackPointsAdd_gte?: Maybe<Int>;
  secondLevelSpells?: Maybe<Int>;
  secondLevelSpells_not?: Maybe<Int>;
  secondLevelSpells_in?: Maybe<Int[] | Int>;
  secondLevelSpells_not_in?: Maybe<Int[] | Int>;
  secondLevelSpells_lt?: Maybe<Int>;
  secondLevelSpells_lte?: Maybe<Int>;
  secondLevelSpells_gt?: Maybe<Int>;
  secondLevelSpells_gte?: Maybe<Int>;
  secondToHitBonus?: Maybe<Int>;
  secondToHitBonus_not?: Maybe<Int>;
  secondToHitBonus_in?: Maybe<Int[] | Int>;
  secondToHitBonus_not_in?: Maybe<Int[] | Int>;
  secondToHitBonus_lt?: Maybe<Int>;
  secondToHitBonus_lte?: Maybe<Int>;
  secondToHitBonus_gt?: Maybe<Int>;
  secondToHitBonus_gte?: Maybe<Int>;
  seventhLevelSpells?: Maybe<Int>;
  seventhLevelSpells_not?: Maybe<Int>;
  seventhLevelSpells_in?: Maybe<Int[] | Int>;
  seventhLevelSpells_not_in?: Maybe<Int[] | Int>;
  seventhLevelSpells_lt?: Maybe<Int>;
  seventhLevelSpells_lte?: Maybe<Int>;
  seventhLevelSpells_gt?: Maybe<Int>;
  seventhLevelSpells_gte?: Maybe<Int>;
  sixthLevelSpells?: Maybe<Int>;
  sixthLevelSpells_not?: Maybe<Int>;
  sixthLevelSpells_in?: Maybe<Int[] | Int>;
  sixthLevelSpells_not_in?: Maybe<Int[] | Int>;
  sixthLevelSpells_lt?: Maybe<Int>;
  sixthLevelSpells_lte?: Maybe<Int>;
  sixthLevelSpells_gt?: Maybe<Int>;
  sixthLevelSpells_gte?: Maybe<Int>;
  spellAttack?: Maybe<Int>;
  spellAttack_not?: Maybe<Int>;
  spellAttack_in?: Maybe<Int[] | Int>;
  spellAttack_not_in?: Maybe<Int[] | Int>;
  spellAttack_lt?: Maybe<Int>;
  spellAttack_lte?: Maybe<Int>;
  spellAttack_gt?: Maybe<Int>;
  spellAttack_gte?: Maybe<Int>;
  spellSave?: Maybe<Int>;
  spellSave_not?: Maybe<Int>;
  spellSave_in?: Maybe<Int[] | Int>;
  spellSave_not_in?: Maybe<Int[] | Int>;
  spellSave_lt?: Maybe<Int>;
  spellSave_lte?: Maybe<Int>;
  spellSave_gt?: Maybe<Int>;
  spellSave_gte?: Maybe<Int>;
  thirdLevelSpells?: Maybe<Int>;
  thirdLevelSpells_not?: Maybe<Int>;
  thirdLevelSpells_in?: Maybe<Int[] | Int>;
  thirdLevelSpells_not_in?: Maybe<Int[] | Int>;
  thirdLevelSpells_lt?: Maybe<Int>;
  thirdLevelSpells_lte?: Maybe<Int>;
  thirdLevelSpells_gt?: Maybe<Int>;
  thirdLevelSpells_gte?: Maybe<Int>;
  toHitBonus?: Maybe<Int>;
  toHitBonus_not?: Maybe<Int>;
  toHitBonus_in?: Maybe<Int[] | Int>;
  toHitBonus_not_in?: Maybe<Int[] | Int>;
  toHitBonus_lt?: Maybe<Int>;
  toHitBonus_lte?: Maybe<Int>;
  toHitBonus_gt?: Maybe<Int>;
  toHitBonus_gte?: Maybe<Int>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PartyWhereInput[] | PartyWhereInput>;
  OR?: Maybe<PartyWhereInput[] | PartyWhereInput>;
  NOT?: Maybe<PartyWhereInput[] | PartyWhereInput>;
}

export interface PartyUpdateWithWhereUniqueWithoutSavedPartyIdInput {
  where: PartyWhereUniqueInput;
  data: PartyUpdateWithoutSavedPartyIdDataInput;
}

export interface PartyUpdateManyWithWhereNestedInput {
  where: PartyScalarWhereInput;
  data: PartyUpdateManyDataInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface SavedPartyPreviousValues {
  id: Int;
  createdAt: DateTimeOutput;
  name: String;
  updatedAt: DateTimeOutput;
}

export interface SavedPartyPreviousValuesPromise
  extends Promise<SavedPartyPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SavedPartyPreviousValuesSubscription
  extends Promise<AsyncIterator<SavedPartyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EncounterEdge {
  node: Encounter;
  cursor: String;
}

export interface EncounterEdgePromise
  extends Promise<EncounterEdge>,
    Fragmentable {
  node: <T = EncounterPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EncounterEdgeSubscription
  extends Promise<AsyncIterator<EncounterEdge>>,
    Fragmentable {
  node: <T = EncounterSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EncounterCreature {
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface EncounterCreaturePromise
  extends Promise<EncounterCreature>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface EncounterCreatureSubscription
  extends Promise<AsyncIterator<EncounterCreature>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EncounterCreatureNullablePromise
  extends Promise<EncounterCreature | null>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AggregateEncounter {
  count: Int;
}

export interface AggregateEncounterPromise
  extends Promise<AggregateEncounter>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEncounterSubscription
  extends Promise<AsyncIterator<AggregateEncounter>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface EncounterConnection {
  pageInfo: PageInfo;
  edges: EncounterEdge[];
}

export interface EncounterConnectionPromise
  extends Promise<EncounterConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EncounterEdge>>() => T;
  aggregate: <T = AggregateEncounterPromise>() => T;
}

export interface EncounterConnectionSubscription
  extends Promise<AsyncIterator<EncounterConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EncounterEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEncounterSubscription>() => T;
}

export interface PartyPreviousValues {
  id: Int;
  armorClass?: Int;
  attackDiceType?: Int;
  attackHitDieNumber?: Int;
  attackNameAndType?: String;
  attackPointsAdd?: Int;
  createdAt: DateTimeOutput;
  eighthLevelSpells?: Int;
  fifthLevelSpells?: Int;
  firstLevelSpells?: Int;
  fourthLevelSpells?: Int;
  hitDiceNumber?: Int;
  hitDiceType?: Int;
  hitPoints?: Int;
  hitPointsAdd?: Int;
  imageUrl?: String;
  initiativeBonus?: Int;
  movementSpeed?: Int;
  name: String;
  ninthLevelSpells?: Int;
  secondAttackDiceType?: Int;
  secondAttackHitDieNumber?: Int;
  secondAttackNameAndType?: String;
  secondAttackPointsAdd?: Int;
  secondLevelSpells?: Int;
  secondToHitBonus?: Int;
  seventhLevelSpells?: Int;
  sixthLevelSpells?: Int;
  spellAttack?: Int;
  spellSave?: Int;
  thirdLevelSpells?: Int;
  toHitBonus?: Int;
  updatedAt: DateTimeOutput;
}

export interface PartyPreviousValuesPromise
  extends Promise<PartyPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  armorClass: () => Promise<Int>;
  attackDiceType: () => Promise<Int>;
  attackHitDieNumber: () => Promise<Int>;
  attackNameAndType: () => Promise<String>;
  attackPointsAdd: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  eighthLevelSpells: () => Promise<Int>;
  fifthLevelSpells: () => Promise<Int>;
  firstLevelSpells: () => Promise<Int>;
  fourthLevelSpells: () => Promise<Int>;
  hitDiceNumber: () => Promise<Int>;
  hitDiceType: () => Promise<Int>;
  hitPoints: () => Promise<Int>;
  hitPointsAdd: () => Promise<Int>;
  imageUrl: () => Promise<String>;
  initiativeBonus: () => Promise<Int>;
  movementSpeed: () => Promise<Int>;
  name: () => Promise<String>;
  ninthLevelSpells: () => Promise<Int>;
  secondAttackDiceType: () => Promise<Int>;
  secondAttackHitDieNumber: () => Promise<Int>;
  secondAttackNameAndType: () => Promise<String>;
  secondAttackPointsAdd: () => Promise<Int>;
  secondLevelSpells: () => Promise<Int>;
  secondToHitBonus: () => Promise<Int>;
  seventhLevelSpells: () => Promise<Int>;
  sixthLevelSpells: () => Promise<Int>;
  spellAttack: () => Promise<Int>;
  spellSave: () => Promise<Int>;
  thirdLevelSpells: () => Promise<Int>;
  toHitBonus: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PartyPreviousValuesSubscription
  extends Promise<AsyncIterator<PartyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  armorClass: () => Promise<AsyncIterator<Int>>;
  attackDiceType: () => Promise<AsyncIterator<Int>>;
  attackHitDieNumber: () => Promise<AsyncIterator<Int>>;
  attackNameAndType: () => Promise<AsyncIterator<String>>;
  attackPointsAdd: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  eighthLevelSpells: () => Promise<AsyncIterator<Int>>;
  fifthLevelSpells: () => Promise<AsyncIterator<Int>>;
  firstLevelSpells: () => Promise<AsyncIterator<Int>>;
  fourthLevelSpells: () => Promise<AsyncIterator<Int>>;
  hitDiceNumber: () => Promise<AsyncIterator<Int>>;
  hitDiceType: () => Promise<AsyncIterator<Int>>;
  hitPoints: () => Promise<AsyncIterator<Int>>;
  hitPointsAdd: () => Promise<AsyncIterator<Int>>;
  imageUrl: () => Promise<AsyncIterator<String>>;
  initiativeBonus: () => Promise<AsyncIterator<Int>>;
  movementSpeed: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  ninthLevelSpells: () => Promise<AsyncIterator<Int>>;
  secondAttackDiceType: () => Promise<AsyncIterator<Int>>;
  secondAttackHitDieNumber: () => Promise<AsyncIterator<Int>>;
  secondAttackNameAndType: () => Promise<AsyncIterator<String>>;
  secondAttackPointsAdd: () => Promise<AsyncIterator<Int>>;
  secondLevelSpells: () => Promise<AsyncIterator<Int>>;
  secondToHitBonus: () => Promise<AsyncIterator<Int>>;
  seventhLevelSpells: () => Promise<AsyncIterator<Int>>;
  sixthLevelSpells: () => Promise<AsyncIterator<Int>>;
  spellAttack: () => Promise<AsyncIterator<Int>>;
  spellSave: () => Promise<AsyncIterator<Int>>;
  thirdLevelSpells: () => Promise<AsyncIterator<Int>>;
  toHitBonus: () => Promise<AsyncIterator<Int>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SavedPartyEdge {
  node: SavedParty;
  cursor: String;
}

export interface SavedPartyEdgePromise
  extends Promise<SavedPartyEdge>,
    Fragmentable {
  node: <T = SavedPartyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SavedPartyEdgeSubscription
  extends Promise<AsyncIterator<SavedPartyEdge>>,
    Fragmentable {
  node: <T = SavedPartySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Encounter {
  id: Int;
  createdAt: DateTimeOutput;
  name: String;
  updatedAt: DateTimeOutput;
}

export interface EncounterPromise extends Promise<Encounter>, Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  encounterCreature: <T = FragmentableArray<EncounterCreature>>(args?: {
    where?: EncounterCreatureWhereInput;
    orderBy?: EncounterCreatureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface EncounterSubscription
  extends Promise<AsyncIterator<Encounter>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  encounterCreature: <
    T = Promise<AsyncIterator<EncounterCreatureSubscription>>
  >(args?: {
    where?: EncounterCreatureWhereInput;
    orderBy?: EncounterCreatureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EncounterNullablePromise
  extends Promise<Encounter | null>,
    Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  encounterCreature: <T = FragmentableArray<EncounterCreature>>(args?: {
    where?: EncounterCreatureWhereInput;
    orderBy?: EncounterCreatureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SavedPartySubscriptionPayload {
  mutation: MutationType;
  node: SavedParty;
  updatedFields: String[];
  previousValues: SavedPartyPreviousValues;
}

export interface SavedPartySubscriptionPayloadPromise
  extends Promise<SavedPartySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SavedPartyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SavedPartyPreviousValuesPromise>() => T;
}

export interface SavedPartySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SavedPartySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SavedPartySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SavedPartyPreviousValuesSubscription>() => T;
}

export interface AggregateCreature {
  count: Int;
}

export interface AggregateCreaturePromise
  extends Promise<AggregateCreature>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCreatureSubscription
  extends Promise<AsyncIterator<AggregateCreature>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PartyEdge {
  node: Party;
  cursor: String;
}

export interface PartyEdgePromise extends Promise<PartyEdge>, Fragmentable {
  node: <T = PartyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PartyEdgeSubscription
  extends Promise<AsyncIterator<PartyEdge>>,
    Fragmentable {
  node: <T = PartySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Creature {
  id: Int;
  armorClass?: Int;
  attackDiceType?: Int;
  attackHitDieNumber?: Int;
  attackNameAndType?: String;
  attackPointsAdd?: Int;
  createdAt: DateTimeOutput;
  eighthLevelSpells?: Int;
  fifthLevelSpells?: Int;
  firstLevelSpells?: Int;
  fourthLevelSpells?: Int;
  hitDiceNumber?: Int;
  hitDiceType?: Int;
  hitPointsAdd?: Int;
  imageUrl?: String;
  initiativeBonus?: Int;
  movementSpeed?: Int;
  name: String;
  ninthLevelSpells?: Int;
  secondAttackDiceType?: Int;
  secondAttackHitDieNumber?: Int;
  secondAttackNameAndType?: String;
  secondAttackPointsAdd?: Int;
  secondLevelSpells?: Int;
  secondToHitBonus?: Int;
  seventhLevelSpells?: Int;
  sixthLevelSpells?: Int;
  spellAttack?: Int;
  spellSave?: Int;
  thirdLevelSpells?: Int;
  toHitBonus?: Int;
  updatedAt: DateTimeOutput;
}

export interface CreaturePromise extends Promise<Creature>, Fragmentable {
  id: () => Promise<Int>;
  armorClass: () => Promise<Int>;
  attackDiceType: () => Promise<Int>;
  attackHitDieNumber: () => Promise<Int>;
  attackNameAndType: () => Promise<String>;
  attackPointsAdd: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  eighthLevelSpells: () => Promise<Int>;
  encounterCreature: <T = FragmentableArray<EncounterCreature>>(args?: {
    where?: EncounterCreatureWhereInput;
    orderBy?: EncounterCreatureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  fifthLevelSpells: () => Promise<Int>;
  firstLevelSpells: () => Promise<Int>;
  fourthLevelSpells: () => Promise<Int>;
  hitDiceNumber: () => Promise<Int>;
  hitDiceType: () => Promise<Int>;
  hitPointsAdd: () => Promise<Int>;
  imageUrl: () => Promise<String>;
  initiativeBonus: () => Promise<Int>;
  movementSpeed: () => Promise<Int>;
  name: () => Promise<String>;
  ninthLevelSpells: () => Promise<Int>;
  secondAttackDiceType: () => Promise<Int>;
  secondAttackHitDieNumber: () => Promise<Int>;
  secondAttackNameAndType: () => Promise<String>;
  secondAttackPointsAdd: () => Promise<Int>;
  secondLevelSpells: () => Promise<Int>;
  secondToHitBonus: () => Promise<Int>;
  seventhLevelSpells: () => Promise<Int>;
  sixthLevelSpells: () => Promise<Int>;
  spellAttack: () => Promise<Int>;
  spellSave: () => Promise<Int>;
  thirdLevelSpells: () => Promise<Int>;
  toHitBonus: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CreatureSubscription
  extends Promise<AsyncIterator<Creature>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  armorClass: () => Promise<AsyncIterator<Int>>;
  attackDiceType: () => Promise<AsyncIterator<Int>>;
  attackHitDieNumber: () => Promise<AsyncIterator<Int>>;
  attackNameAndType: () => Promise<AsyncIterator<String>>;
  attackPointsAdd: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  eighthLevelSpells: () => Promise<AsyncIterator<Int>>;
  encounterCreature: <
    T = Promise<AsyncIterator<EncounterCreatureSubscription>>
  >(args?: {
    where?: EncounterCreatureWhereInput;
    orderBy?: EncounterCreatureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  fifthLevelSpells: () => Promise<AsyncIterator<Int>>;
  firstLevelSpells: () => Promise<AsyncIterator<Int>>;
  fourthLevelSpells: () => Promise<AsyncIterator<Int>>;
  hitDiceNumber: () => Promise<AsyncIterator<Int>>;
  hitDiceType: () => Promise<AsyncIterator<Int>>;
  hitPointsAdd: () => Promise<AsyncIterator<Int>>;
  imageUrl: () => Promise<AsyncIterator<String>>;
  initiativeBonus: () => Promise<AsyncIterator<Int>>;
  movementSpeed: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  ninthLevelSpells: () => Promise<AsyncIterator<Int>>;
  secondAttackDiceType: () => Promise<AsyncIterator<Int>>;
  secondAttackHitDieNumber: () => Promise<AsyncIterator<Int>>;
  secondAttackNameAndType: () => Promise<AsyncIterator<String>>;
  secondAttackPointsAdd: () => Promise<AsyncIterator<Int>>;
  secondLevelSpells: () => Promise<AsyncIterator<Int>>;
  secondToHitBonus: () => Promise<AsyncIterator<Int>>;
  seventhLevelSpells: () => Promise<AsyncIterator<Int>>;
  sixthLevelSpells: () => Promise<AsyncIterator<Int>>;
  spellAttack: () => Promise<AsyncIterator<Int>>;
  spellSave: () => Promise<AsyncIterator<Int>>;
  thirdLevelSpells: () => Promise<AsyncIterator<Int>>;
  toHitBonus: () => Promise<AsyncIterator<Int>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CreatureNullablePromise
  extends Promise<Creature | null>,
    Fragmentable {
  id: () => Promise<Int>;
  armorClass: () => Promise<Int>;
  attackDiceType: () => Promise<Int>;
  attackHitDieNumber: () => Promise<Int>;
  attackNameAndType: () => Promise<String>;
  attackPointsAdd: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  eighthLevelSpells: () => Promise<Int>;
  encounterCreature: <T = FragmentableArray<EncounterCreature>>(args?: {
    where?: EncounterCreatureWhereInput;
    orderBy?: EncounterCreatureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  fifthLevelSpells: () => Promise<Int>;
  firstLevelSpells: () => Promise<Int>;
  fourthLevelSpells: () => Promise<Int>;
  hitDiceNumber: () => Promise<Int>;
  hitDiceType: () => Promise<Int>;
  hitPointsAdd: () => Promise<Int>;
  imageUrl: () => Promise<String>;
  initiativeBonus: () => Promise<Int>;
  movementSpeed: () => Promise<Int>;
  name: () => Promise<String>;
  ninthLevelSpells: () => Promise<Int>;
  secondAttackDiceType: () => Promise<Int>;
  secondAttackHitDieNumber: () => Promise<Int>;
  secondAttackNameAndType: () => Promise<String>;
  secondAttackPointsAdd: () => Promise<Int>;
  secondLevelSpells: () => Promise<Int>;
  secondToHitBonus: () => Promise<Int>;
  seventhLevelSpells: () => Promise<Int>;
  sixthLevelSpells: () => Promise<Int>;
  spellAttack: () => Promise<Int>;
  spellSave: () => Promise<Int>;
  thirdLevelSpells: () => Promise<Int>;
  toHitBonus: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CreatureConnection {
  pageInfo: PageInfo;
  edges: CreatureEdge[];
}

export interface CreatureConnectionPromise
  extends Promise<CreatureConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CreatureEdge>>() => T;
  aggregate: <T = AggregateCreaturePromise>() => T;
}

export interface CreatureConnectionSubscription
  extends Promise<AsyncIterator<CreatureConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CreatureEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCreatureSubscription>() => T;
}

export interface CreatureSubscriptionPayload {
  mutation: MutationType;
  node: Creature;
  updatedFields: String[];
  previousValues: CreaturePreviousValues;
}

export interface CreatureSubscriptionPayloadPromise
  extends Promise<CreatureSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CreaturePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CreaturePreviousValuesPromise>() => T;
}

export interface CreatureSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CreatureSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CreatureSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CreaturePreviousValuesSubscription>() => T;
}

export interface Party {
  id: Int;
  armorClass?: Int;
  attackDiceType?: Int;
  attackHitDieNumber?: Int;
  attackNameAndType?: String;
  attackPointsAdd?: Int;
  createdAt: DateTimeOutput;
  eighthLevelSpells?: Int;
  fifthLevelSpells?: Int;
  firstLevelSpells?: Int;
  fourthLevelSpells?: Int;
  hitDiceNumber?: Int;
  hitDiceType?: Int;
  hitPoints?: Int;
  hitPointsAdd?: Int;
  imageUrl?: String;
  initiativeBonus?: Int;
  movementSpeed?: Int;
  name: String;
  ninthLevelSpells?: Int;
  secondAttackDiceType?: Int;
  secondAttackHitDieNumber?: Int;
  secondAttackNameAndType?: String;
  secondAttackPointsAdd?: Int;
  secondLevelSpells?: Int;
  secondToHitBonus?: Int;
  seventhLevelSpells?: Int;
  sixthLevelSpells?: Int;
  spellAttack?: Int;
  spellSave?: Int;
  thirdLevelSpells?: Int;
  toHitBonus?: Int;
  updatedAt: DateTimeOutput;
}

export interface PartyPromise extends Promise<Party>, Fragmentable {
  id: () => Promise<Int>;
  armorClass: () => Promise<Int>;
  attackDiceType: () => Promise<Int>;
  attackHitDieNumber: () => Promise<Int>;
  attackNameAndType: () => Promise<String>;
  attackPointsAdd: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  eighthLevelSpells: () => Promise<Int>;
  fifthLevelSpells: () => Promise<Int>;
  firstLevelSpells: () => Promise<Int>;
  fourthLevelSpells: () => Promise<Int>;
  hitDiceNumber: () => Promise<Int>;
  hitDiceType: () => Promise<Int>;
  hitPoints: () => Promise<Int>;
  hitPointsAdd: () => Promise<Int>;
  imageUrl: () => Promise<String>;
  initiativeBonus: () => Promise<Int>;
  movementSpeed: () => Promise<Int>;
  name: () => Promise<String>;
  ninthLevelSpells: () => Promise<Int>;
  savedPartyId: <T = SavedPartyPromise>() => T;
  secondAttackDiceType: () => Promise<Int>;
  secondAttackHitDieNumber: () => Promise<Int>;
  secondAttackNameAndType: () => Promise<String>;
  secondAttackPointsAdd: () => Promise<Int>;
  secondLevelSpells: () => Promise<Int>;
  secondToHitBonus: () => Promise<Int>;
  seventhLevelSpells: () => Promise<Int>;
  sixthLevelSpells: () => Promise<Int>;
  spellAttack: () => Promise<Int>;
  spellSave: () => Promise<Int>;
  thirdLevelSpells: () => Promise<Int>;
  toHitBonus: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PartySubscription
  extends Promise<AsyncIterator<Party>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  armorClass: () => Promise<AsyncIterator<Int>>;
  attackDiceType: () => Promise<AsyncIterator<Int>>;
  attackHitDieNumber: () => Promise<AsyncIterator<Int>>;
  attackNameAndType: () => Promise<AsyncIterator<String>>;
  attackPointsAdd: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  eighthLevelSpells: () => Promise<AsyncIterator<Int>>;
  fifthLevelSpells: () => Promise<AsyncIterator<Int>>;
  firstLevelSpells: () => Promise<AsyncIterator<Int>>;
  fourthLevelSpells: () => Promise<AsyncIterator<Int>>;
  hitDiceNumber: () => Promise<AsyncIterator<Int>>;
  hitDiceType: () => Promise<AsyncIterator<Int>>;
  hitPoints: () => Promise<AsyncIterator<Int>>;
  hitPointsAdd: () => Promise<AsyncIterator<Int>>;
  imageUrl: () => Promise<AsyncIterator<String>>;
  initiativeBonus: () => Promise<AsyncIterator<Int>>;
  movementSpeed: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  ninthLevelSpells: () => Promise<AsyncIterator<Int>>;
  savedPartyId: <T = SavedPartySubscription>() => T;
  secondAttackDiceType: () => Promise<AsyncIterator<Int>>;
  secondAttackHitDieNumber: () => Promise<AsyncIterator<Int>>;
  secondAttackNameAndType: () => Promise<AsyncIterator<String>>;
  secondAttackPointsAdd: () => Promise<AsyncIterator<Int>>;
  secondLevelSpells: () => Promise<AsyncIterator<Int>>;
  secondToHitBonus: () => Promise<AsyncIterator<Int>>;
  seventhLevelSpells: () => Promise<AsyncIterator<Int>>;
  sixthLevelSpells: () => Promise<AsyncIterator<Int>>;
  spellAttack: () => Promise<AsyncIterator<Int>>;
  spellSave: () => Promise<AsyncIterator<Int>>;
  thirdLevelSpells: () => Promise<AsyncIterator<Int>>;
  toHitBonus: () => Promise<AsyncIterator<Int>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PartyNullablePromise
  extends Promise<Party | null>,
    Fragmentable {
  id: () => Promise<Int>;
  armorClass: () => Promise<Int>;
  attackDiceType: () => Promise<Int>;
  attackHitDieNumber: () => Promise<Int>;
  attackNameAndType: () => Promise<String>;
  attackPointsAdd: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  eighthLevelSpells: () => Promise<Int>;
  fifthLevelSpells: () => Promise<Int>;
  firstLevelSpells: () => Promise<Int>;
  fourthLevelSpells: () => Promise<Int>;
  hitDiceNumber: () => Promise<Int>;
  hitDiceType: () => Promise<Int>;
  hitPoints: () => Promise<Int>;
  hitPointsAdd: () => Promise<Int>;
  imageUrl: () => Promise<String>;
  initiativeBonus: () => Promise<Int>;
  movementSpeed: () => Promise<Int>;
  name: () => Promise<String>;
  ninthLevelSpells: () => Promise<Int>;
  savedPartyId: <T = SavedPartyPromise>() => T;
  secondAttackDiceType: () => Promise<Int>;
  secondAttackHitDieNumber: () => Promise<Int>;
  secondAttackNameAndType: () => Promise<String>;
  secondAttackPointsAdd: () => Promise<Int>;
  secondLevelSpells: () => Promise<Int>;
  secondToHitBonus: () => Promise<Int>;
  seventhLevelSpells: () => Promise<Int>;
  sixthLevelSpells: () => Promise<Int>;
  spellAttack: () => Promise<Int>;
  spellSave: () => Promise<Int>;
  thirdLevelSpells: () => Promise<Int>;
  toHitBonus: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CreaturePreviousValues {
  id: Int;
  armorClass?: Int;
  attackDiceType?: Int;
  attackHitDieNumber?: Int;
  attackNameAndType?: String;
  attackPointsAdd?: Int;
  createdAt: DateTimeOutput;
  eighthLevelSpells?: Int;
  fifthLevelSpells?: Int;
  firstLevelSpells?: Int;
  fourthLevelSpells?: Int;
  hitDiceNumber?: Int;
  hitDiceType?: Int;
  hitPointsAdd?: Int;
  imageUrl?: String;
  initiativeBonus?: Int;
  movementSpeed?: Int;
  name: String;
  ninthLevelSpells?: Int;
  secondAttackDiceType?: Int;
  secondAttackHitDieNumber?: Int;
  secondAttackNameAndType?: String;
  secondAttackPointsAdd?: Int;
  secondLevelSpells?: Int;
  secondToHitBonus?: Int;
  seventhLevelSpells?: Int;
  sixthLevelSpells?: Int;
  spellAttack?: Int;
  spellSave?: Int;
  thirdLevelSpells?: Int;
  toHitBonus?: Int;
  updatedAt: DateTimeOutput;
}

export interface CreaturePreviousValuesPromise
  extends Promise<CreaturePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  armorClass: () => Promise<Int>;
  attackDiceType: () => Promise<Int>;
  attackHitDieNumber: () => Promise<Int>;
  attackNameAndType: () => Promise<String>;
  attackPointsAdd: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  eighthLevelSpells: () => Promise<Int>;
  fifthLevelSpells: () => Promise<Int>;
  firstLevelSpells: () => Promise<Int>;
  fourthLevelSpells: () => Promise<Int>;
  hitDiceNumber: () => Promise<Int>;
  hitDiceType: () => Promise<Int>;
  hitPointsAdd: () => Promise<Int>;
  imageUrl: () => Promise<String>;
  initiativeBonus: () => Promise<Int>;
  movementSpeed: () => Promise<Int>;
  name: () => Promise<String>;
  ninthLevelSpells: () => Promise<Int>;
  secondAttackDiceType: () => Promise<Int>;
  secondAttackHitDieNumber: () => Promise<Int>;
  secondAttackNameAndType: () => Promise<String>;
  secondAttackPointsAdd: () => Promise<Int>;
  secondLevelSpells: () => Promise<Int>;
  secondToHitBonus: () => Promise<Int>;
  seventhLevelSpells: () => Promise<Int>;
  sixthLevelSpells: () => Promise<Int>;
  spellAttack: () => Promise<Int>;
  spellSave: () => Promise<Int>;
  thirdLevelSpells: () => Promise<Int>;
  toHitBonus: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CreaturePreviousValuesSubscription
  extends Promise<AsyncIterator<CreaturePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  armorClass: () => Promise<AsyncIterator<Int>>;
  attackDiceType: () => Promise<AsyncIterator<Int>>;
  attackHitDieNumber: () => Promise<AsyncIterator<Int>>;
  attackNameAndType: () => Promise<AsyncIterator<String>>;
  attackPointsAdd: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  eighthLevelSpells: () => Promise<AsyncIterator<Int>>;
  fifthLevelSpells: () => Promise<AsyncIterator<Int>>;
  firstLevelSpells: () => Promise<AsyncIterator<Int>>;
  fourthLevelSpells: () => Promise<AsyncIterator<Int>>;
  hitDiceNumber: () => Promise<AsyncIterator<Int>>;
  hitDiceType: () => Promise<AsyncIterator<Int>>;
  hitPointsAdd: () => Promise<AsyncIterator<Int>>;
  imageUrl: () => Promise<AsyncIterator<String>>;
  initiativeBonus: () => Promise<AsyncIterator<Int>>;
  movementSpeed: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  ninthLevelSpells: () => Promise<AsyncIterator<Int>>;
  secondAttackDiceType: () => Promise<AsyncIterator<Int>>;
  secondAttackHitDieNumber: () => Promise<AsyncIterator<Int>>;
  secondAttackNameAndType: () => Promise<AsyncIterator<String>>;
  secondAttackPointsAdd: () => Promise<AsyncIterator<Int>>;
  secondLevelSpells: () => Promise<AsyncIterator<Int>>;
  secondToHitBonus: () => Promise<AsyncIterator<Int>>;
  seventhLevelSpells: () => Promise<AsyncIterator<Int>>;
  sixthLevelSpells: () => Promise<AsyncIterator<Int>>;
  spellAttack: () => Promise<AsyncIterator<Int>>;
  spellSave: () => Promise<AsyncIterator<Int>>;
  thirdLevelSpells: () => Promise<AsyncIterator<Int>>;
  toHitBonus: () => Promise<AsyncIterator<Int>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EncounterCreatureEdge {
  node: EncounterCreature;
  cursor: String;
}

export interface EncounterCreatureEdgePromise
  extends Promise<EncounterCreatureEdge>,
    Fragmentable {
  node: <T = EncounterCreaturePromise>() => T;
  cursor: () => Promise<String>;
}

export interface EncounterCreatureEdgeSubscription
  extends Promise<AsyncIterator<EncounterCreatureEdge>>,
    Fragmentable {
  node: <T = EncounterCreatureSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CreatureEdge {
  node: Creature;
  cursor: String;
}

export interface CreatureEdgePromise
  extends Promise<CreatureEdge>,
    Fragmentable {
  node: <T = CreaturePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CreatureEdgeSubscription
  extends Promise<AsyncIterator<CreatureEdge>>,
    Fragmentable {
  node: <T = CreatureSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSavedParty {
  count: Int;
}

export interface AggregateSavedPartyPromise
  extends Promise<AggregateSavedParty>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSavedPartySubscription
  extends Promise<AsyncIterator<AggregateSavedParty>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EncounterSubscriptionPayload {
  mutation: MutationType;
  node: Encounter;
  updatedFields: String[];
  previousValues: EncounterPreviousValues;
}

export interface EncounterSubscriptionPayloadPromise
  extends Promise<EncounterSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EncounterPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EncounterPreviousValuesPromise>() => T;
}

export interface EncounterSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EncounterSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EncounterSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EncounterPreviousValuesSubscription>() => T;
}

export interface AggregateParty {
  count: Int;
}

export interface AggregatePartyPromise
  extends Promise<AggregateParty>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePartySubscription
  extends Promise<AsyncIterator<AggregateParty>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SavedParty {
  id: Int;
  createdAt: DateTimeOutput;
  name: String;
  updatedAt: DateTimeOutput;
}

export interface SavedPartyPromise extends Promise<SavedParty>, Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  parties: <T = FragmentableArray<Party>>(args?: {
    where?: PartyWhereInput;
    orderBy?: PartyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SavedPartySubscription
  extends Promise<AsyncIterator<SavedParty>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  parties: <T = Promise<AsyncIterator<PartySubscription>>>(args?: {
    where?: PartyWhereInput;
    orderBy?: PartyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SavedPartyNullablePromise
  extends Promise<SavedParty | null>,
    Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  parties: <T = FragmentableArray<Party>>(args?: {
    where?: PartyWhereInput;
    orderBy?: PartyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface EncounterCreaturePreviousValues {
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface EncounterCreaturePreviousValuesPromise
  extends Promise<EncounterCreaturePreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface EncounterCreaturePreviousValuesSubscription
  extends Promise<AsyncIterator<EncounterCreaturePreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EncounterCreatureSubscriptionPayload {
  mutation: MutationType;
  node: EncounterCreature;
  updatedFields: String[];
  previousValues: EncounterCreaturePreviousValues;
}

export interface EncounterCreatureSubscriptionPayloadPromise
  extends Promise<EncounterCreatureSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EncounterCreaturePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EncounterCreaturePreviousValuesPromise>() => T;
}

export interface EncounterCreatureSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EncounterCreatureSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EncounterCreatureSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EncounterCreaturePreviousValuesSubscription>() => T;
}

export interface PartySubscriptionPayload {
  mutation: MutationType;
  node: Party;
  updatedFields: String[];
  previousValues: PartyPreviousValues;
}

export interface PartySubscriptionPayloadPromise
  extends Promise<PartySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PartyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PartyPreviousValuesPromise>() => T;
}

export interface PartySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PartySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PartySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PartyPreviousValuesSubscription>() => T;
}

export interface EncounterPreviousValues {
  id: Int;
  createdAt: DateTimeOutput;
  name: String;
  updatedAt: DateTimeOutput;
}

export interface EncounterPreviousValuesPromise
  extends Promise<EncounterPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface EncounterPreviousValuesSubscription
  extends Promise<AsyncIterator<EncounterPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateEncounterCreature {
  count: Int;
}

export interface AggregateEncounterCreaturePromise
  extends Promise<AggregateEncounterCreature>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEncounterCreatureSubscription
  extends Promise<AsyncIterator<AggregateEncounterCreature>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PartyConnection {
  pageInfo: PageInfo;
  edges: PartyEdge[];
}

export interface PartyConnectionPromise
  extends Promise<PartyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PartyEdge>>() => T;
  aggregate: <T = AggregatePartyPromise>() => T;
}

export interface PartyConnectionSubscription
  extends Promise<AsyncIterator<PartyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PartyEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePartySubscription>() => T;
}

export interface SavedPartyConnection {
  pageInfo: PageInfo;
  edges: SavedPartyEdge[];
}

export interface SavedPartyConnectionPromise
  extends Promise<SavedPartyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SavedPartyEdge>>() => T;
  aggregate: <T = AggregateSavedPartyPromise>() => T;
}

export interface SavedPartyConnectionSubscription
  extends Promise<AsyncIterator<SavedPartyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SavedPartyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSavedPartySubscription>() => T;
}

export interface EncounterCreatureConnection {
  pageInfo: PageInfo;
  edges: EncounterCreatureEdge[];
}

export interface EncounterCreatureConnectionPromise
  extends Promise<EncounterCreatureConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EncounterCreatureEdge>>() => T;
  aggregate: <T = AggregateEncounterCreaturePromise>() => T;
}

export interface EncounterCreatureConnectionSubscription
  extends Promise<AsyncIterator<EncounterCreatureConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EncounterCreatureEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEncounterCreatureSubscription>() => T;
}

export type Long = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Creature",
    embedded: false
  },
  {
    name: "Encounter",
    embedded: false
  },
  {
    name: "EncounterCreature",
    embedded: false
  },
  {
    name: "Party",
    embedded: false
  },
  {
    name: "SavedParty",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
